{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport ViscousFluidInterpolator from \"./ViscousFluidInterpolator\";\nimport { currentAnimationTimeMillis } from \"./AnimationUtils\";\nvar SCROLL_FRICTION = 0.03;\nvar DEFAULT_DURATION = 250;\nvar SCROLL_MODE = 0;\nvar FLING_MODE = 1;\nvar DECELERATION_RATE = Math.log(0.78) / Math.log(0.9);\nvar INFLEXION = 0.35;\nvar START_TENSION = 0.5;\nvar END_TENSION = 1.0;\nvar P1 = START_TENSION * INFLEXION;\nvar P2 = 1.0 - END_TENSION * (1.0 - INFLEXION);\nvar NB_SAMPLES = 100;\nvar SPLINE_POSITION = [];\nvar SPLINE_TIME = [];\nvar GRAVITY_EARTH = 9.80665;\n\n(function () {\n  var x_min = 0;\n  var y_min = 0;\n\n  for (var i = 0; i < NB_SAMPLES; i++) {\n    var alpha = i / NB_SAMPLES;\n    var x_max = 1;\n    var x = void 0,\n        tx = void 0,\n        coef = void 0;\n\n    while (true) {\n      x = x_min + (x_max - x_min) / 2.0;\n      coef = 3.0 * x * (1.0 - x);\n      tx = coef * ((1.0 - x) * P1 + x * P2) + x * x * x;\n      if (Math.abs(tx - alpha) < 1E-5) break;\n      if (tx > alpha) x_max = x;else x_min = x;\n    }\n\n    SPLINE_POSITION[i] = coef * ((1.0 - x) * START_TENSION + x) + x * x * x;\n    var y_max = 1.0;\n    var y = void 0,\n        dy = void 0;\n\n    while (true) {\n      y = y_min + (y_max - y_min) / 2.0;\n      coef = 3.0 * y * (1.0 - y);\n      dy = coef * ((1.0 - y) * START_TENSION + y) + y * y * y;\n      if (Math.abs(dy - alpha) < 1E-5) break;\n      if (dy > alpha) y_max = y;else y_min = y;\n    }\n\n    SPLINE_TIME[i] = coef * ((1.0 - y) * P1 + y * P2) + y * y * y;\n  }\n\n  SPLINE_POSITION[NB_SAMPLES] = SPLINE_TIME[NB_SAMPLES] = 1.0;\n})();\n\nfunction signum(number) {\n  if (isNaN(number)) {\n    return NaN;\n  }\n\n  var sig = number;\n\n  if (number > 0) {\n    sig = 1;\n  } else if (number < 0) {\n    sig = -1;\n  }\n\n  return sig;\n}\n\nvar Scroller = function () {\n  function Scroller(flywheel, onScrollCallback) {\n    _classCallCheck(this, Scroller);\n\n    this.mCurrX = 0;\n    this.mCurrY = 0;\n    this.mFinished = true;\n    this.mInterpolator = ViscousFluidInterpolator;\n    this.mPpi = 160;\n    this.mDeceleration = this.computeDeceleration(SCROLL_FRICTION);\n    this.mFlywheel = flywheel;\n    this.mPhysicalCoeff = this.computeDeceleration(0.84);\n    this.mFlingFriction = SCROLL_FRICTION;\n    this.onScrollCallback = onScrollCallback;\n  }\n\n  _createClass(Scroller, [{\n    key: \"computeDeceleration\",\n    value: function computeDeceleration(friction) {\n      return GRAVITY_EARTH * 39.37 * this.mPpi * friction;\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished() {\n      return this.mFinished;\n    }\n  }, {\n    key: \"forceFinished\",\n    value: function forceFinished(finished) {\n      this.mFinished = finished;\n    }\n  }, {\n    key: \"getCurrX\",\n    value: function getCurrX() {\n      return this.mCurrX;\n    }\n  }, {\n    key: \"getCurrY\",\n    value: function getCurrY() {\n      return this.mCurrY;\n    }\n  }, {\n    key: \"getCurrVelocity\",\n    value: function getCurrVelocity() {\n      return this.mMode === FLING_MODE ? this.mCurrVelocity : this.mVelocity - this.mDeceleration * this.timePassed() / 2000.0;\n    }\n  }, {\n    key: \"computeScrollOffset\",\n    value: function computeScrollOffset() {\n      if (this.mFinished) {\n        this.onScrollCallback && this.onScrollCallback(0, 0, this);\n        return false;\n      }\n\n      var timePassed = currentAnimationTimeMillis() - this.mStartTime;\n\n      if (timePassed < this.mDuration) {\n        switch (this.mMode) {\n          case SCROLL_MODE:\n            var x = this.mInterpolator.getInterpolation(timePassed * this.mDurationReciprocal);\n            this.mCurrX = this.mStartX + Math.round(x * this.mDeltaX);\n            this.mCurrY = this.mStartY + Math.round(x * this.mDeltaY);\n            break;\n\n          case FLING_MODE:\n            var t = timePassed / this.mDuration;\n            var index = parseInt(NB_SAMPLES * t);\n            var distanceCoef = 1;\n            var velocityCoef = 0;\n\n            if (index < NB_SAMPLES) {\n              var t_inf = index / NB_SAMPLES;\n              var t_sup = (index + 1) / NB_SAMPLES;\n              var d_inf = SPLINE_POSITION[index];\n              var d_sup = SPLINE_POSITION[index + 1];\n              velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);\n              distanceCoef = d_inf + (t - t_inf) * velocityCoef;\n            }\n\n            this.mCurrVelocity = velocityCoef * this.mDistance / this.mDuration * 1000;\n            this.mCurrX = this.mStartX + Math.round(distanceCoef * (this.mFinalX - this.mStartX));\n            this.mCurrY = this.mStartY + Math.round(distanceCoef * (this.mFinalY - this.mStartY));\n            this.mCurrY = Math.min(this.mCurrY, this.mMaxY);\n            this.mCurrY = Math.max(this.mCurrY, this.mMinY);\n\n            if (this.mCurrX == this.mFinalX && this.mCurrY == this.mFinalY) {\n              this.mFinished = true;\n            }\n\n            break;\n        }\n      } else {\n        this.mCurrX = this.mFinalX;\n        this.mCurrY = this.mFinalY;\n        this.mFinished = true;\n      }\n\n      var dx = this.mCurrX - this.mLastX;\n      var dy = this.mCurrY - this.mLastY;\n      this.mLastX = this.mCurrX;\n      this.mLastY = this.mCurrY;\n      this.onScrollCallback && this.onScrollCallback(dx, dy, this);\n\n      if (dx === 0 && dy === 0 && this.mFinished) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"startScroll\",\n    value: function startScroll(startX, startY, dx, dy) {\n      var duration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_DURATION;\n      this.mMode = SCROLL_MODE;\n      this.mFinished = false;\n      this.mDuration = duration;\n      this.mStartTime = currentAnimationTimeMillis();\n      this.mStartX = startX;\n      this.mStartY = startY;\n      this.mFinalX = startX + dx;\n      this.mFinalY = startY + dy;\n      this.mDeltaX = dx;\n      this.mDeltaY = dy;\n      this.mDurationReciprocal = 1.0 / this.mDuration;\n      this.mLastX = this.mStartX;\n      this.mLastY = this.mStartY;\n      this.performAnimation();\n    }\n  }, {\n    key: \"fling\",\n    value: function fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY) {\n      if (this.mFlywheel && !this.mFinished) {\n        var oldVel = this.getCurrVelocity();\n        var dx = this.mFinalX - this.mStartX;\n        var dy = this.mFinalY - this.mStartY;\n        var hyp = Math.hypot(dx, dy);\n        var ndx = dx / hyp;\n        var ndy = dy / hyp;\n        var oldVelocityX = ndx * oldVel;\n        var oldVelocityY = ndy * oldVel;\n\n        if (signum(velocityX) === signum(oldVelocityX) && signum(velocityY) === signum(oldVelocityY)) {\n          velocityX += oldVelocityX;\n          velocityY += oldVelocityY;\n        }\n      }\n\n      this.mMode = FLING_MODE;\n      this.mFinished = false;\n      var velocity = Math.hypot(velocityX, velocityY);\n      this.mVelocity = velocity;\n      this.mDuration = this.getSplineFlingDuration(velocity);\n      this.mStartTime = currentAnimationTimeMillis();\n      this.mStartX = startX;\n      this.mStartY = startY;\n      var coeffX = velocity == 0 ? 1.0 : velocityX / velocity;\n      var coeffY = velocity == 0 ? 1.0 : velocityY / velocity;\n      var totalDistance = this.getSplineFlingDistance(velocity);\n      this.mDistance = totalDistance * signum(velocity);\n      this.mMinX = minX;\n      this.mMaxX = maxX;\n      this.mMinY = minY;\n      this.mMaxY = maxY;\n      this.mFinalX = startX + Math.round(totalDistance * coeffX);\n      this.mFinalX = Math.min(this.mFinalX, this.mMaxX);\n      this.mFinalX = Math.max(this.mFinalX, this.mMinX);\n      this.mFinalY = startY + Math.round(totalDistance * coeffY);\n      this.mFinalY = Math.min(this.mFinalY, this.mMaxY);\n      this.mFinalY = Math.max(this.mFinalY, this.mMinY);\n      this.mLastX = this.mStartX;\n      this.mLastY = this.mStartY;\n      this.performAnimation();\n    }\n  }, {\n    key: \"getSplineDeceleration\",\n    value: function getSplineDeceleration(velocity) {\n      return Math.log(INFLEXION * Math.abs(velocity) / (this.mFlingFriction * this.mPhysicalCoeff));\n    }\n  }, {\n    key: \"getSplineFlingDuration\",\n    value: function getSplineFlingDuration(velocity) {\n      var l = this.getSplineDeceleration(velocity);\n      var decelMinusOne = DECELERATION_RATE - 1.0;\n      return 1000.0 * Math.exp(l / decelMinusOne);\n    }\n  }, {\n    key: \"getSplineFlingDistance\",\n    value: function getSplineFlingDistance(velocity) {\n      var l = this.getSplineDeceleration(velocity);\n      var decelMinusOne = DECELERATION_RATE - 1.0;\n      return this.mFlingFriction * this.mPhysicalCoeff * Math.exp(DECELERATION_RATE / decelMinusOne * l);\n    }\n  }, {\n    key: \"performAnimation\",\n    value: function performAnimation() {\n      if (this.computeScrollOffset()) {\n        requestAnimationFrame(this.performAnimation.bind(this));\n      } else {}\n    }\n  }, {\n    key: \"abortAnimation\",\n    value: function abortAnimation() {\n      this.mCurrX = this.mFinalX;\n      this.mCurrY = this.mFinalY;\n      this.mFinished = true;\n    }\n  }, {\n    key: \"extendDuration\",\n    value: function extendDuration(extend) {\n      var passed = timePassed();\n      this.mDuration = passed + extend;\n      this.mDurationReciprocal = 1.0 / this.mDuration;\n      this.mFinished = false;\n    }\n  }, {\n    key: \"timePassed\",\n    value: function timePassed() {\n      return currentAnimationTimeMillis() - this.mStartTime;\n    }\n  }, {\n    key: \"setFinalX\",\n    value: function setFinalX(newX) {\n      this.mFinalX = newX;\n      this.mDeltaX = this.mFinalX - this.mStartX;\n      this.mFinished = false;\n    }\n  }, {\n    key: \"setFinalY\",\n    value: function setFinalY(newY) {\n      this.mFinalY = newY;\n      this.mDeltaY = this.mFinalY - this.mStartY;\n      this.mFinished = false;\n    }\n  }, {\n    key: \"debugInfo\",\n    value: function debugInfo() {\n      return 'cur=' + this.mCurrX + ' ' + this.mCurrY + ', final=' + this.mFinalX + ' ' + this.mFinalY;\n    }\n  }]);\n\n  return Scroller;\n}();\n\nexport { Scroller as default };","map":{"version":3,"sources":["C:/Users/takia/OneDrive/Desktop/Data/Projects/mobile_app/mobile_app/Handoff/node_modules/react-native-image-gallery/src/libraries/Scroller/index.js"],"names":["ViscousFluidInterpolator","currentAnimationTimeMillis","SCROLL_FRICTION","DEFAULT_DURATION","SCROLL_MODE","FLING_MODE","DECELERATION_RATE","Math","log","INFLEXION","START_TENSION","END_TENSION","P1","P2","NB_SAMPLES","SPLINE_POSITION","SPLINE_TIME","GRAVITY_EARTH","x_min","y_min","i","alpha","x_max","x","tx","coef","abs","y_max","y","dy","signum","number","isNaN","NaN","sig","Scroller","flywheel","onScrollCallback","mCurrX","mCurrY","mFinished","mInterpolator","mPpi","mDeceleration","computeDeceleration","mFlywheel","mPhysicalCoeff","mFlingFriction","friction","finished","mMode","mCurrVelocity","mVelocity","timePassed","mStartTime","mDuration","getInterpolation","mDurationReciprocal","mStartX","round","mDeltaX","mStartY","mDeltaY","t","index","parseInt","distanceCoef","velocityCoef","t_inf","t_sup","d_inf","d_sup","mDistance","mFinalX","mFinalY","min","mMaxY","max","mMinY","dx","mLastX","mLastY","startX","startY","duration","performAnimation","velocityX","velocityY","minX","maxX","minY","maxY","oldVel","getCurrVelocity","hyp","hypot","ndx","ndy","oldVelocityX","oldVelocityY","velocity","getSplineFlingDuration","coeffX","coeffY","totalDistance","getSplineFlingDistance","mMinX","mMaxX","l","getSplineDeceleration","decelMinusOne","exp","computeScrollOffset","requestAnimationFrame","bind","extend","passed","newX","newY"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Inspired by Android Scroller\n */\n\nimport ViscousFluidInterpolator from './ViscousFluidInterpolator';\nimport {currentAnimationTimeMillis} from './AnimationUtils';\n\n/**\n * The coefficient of friction applied to flings/scrolls.\n * @type {number}\n */\n// const SCROLL_FRICTION = 0.015;\nconst SCROLL_FRICTION = 0.03;\n\nconst DEFAULT_DURATION = 250;\nconst SCROLL_MODE = 0;\nconst FLING_MODE = 1;\n\nconst DECELERATION_RATE = Math.log(0.78) / Math.log(0.9);\nconst INFLEXION = 0.35; // Tension lines cross at (INFLEXION, 1)\nconst START_TENSION = 0.5;\nconst END_TENSION = 1.0;\nconst P1 = START_TENSION * INFLEXION;\nconst P2 = 1.0 - END_TENSION * (1.0 - INFLEXION);\n\nconst NB_SAMPLES = 100;\nconst SPLINE_POSITION = [];\nconst SPLINE_TIME = [];\n\nconst GRAVITY_EARTH = 9.80665;\n\n(function () {\n    var x_min = 0;\n    var y_min = 0;\n    for (let i = 0; i < NB_SAMPLES; i++) {\n        let alpha = i / NB_SAMPLES;\n\n        let x_max = 1;\n        let x, tx, coef;\n        while (true) {\n            x = x_min + (x_max - x_min) / 2.0;\n            coef = 3.0 * x * (1.0 - x);\n            tx = coef * ((1.0 - x) * P1 + x * P2) + x * x * x;\n            if (Math.abs(tx - alpha) < 1E-5) break;\n            if (tx > alpha) x_max = x;\n            else x_min = x;\n        }\n        SPLINE_POSITION[i] = coef * ((1.0 - x) * START_TENSION + x) + x * x * x;\n\n        let y_max = 1.0;\n        let y, dy;\n        while (true) {\n            y = y_min + (y_max - y_min) / 2.0;\n            coef = 3.0 * y * (1.0 - y);\n            dy = coef * ((1.0 - y) * START_TENSION + y) + y * y * y;\n            if (Math.abs(dy - alpha) < 1E-5) break;\n            if (dy > alpha) y_max = y;\n            else y_min = y;\n        }\n        SPLINE_TIME[i] = coef * ((1.0 - y) * P1 + y * P2) + y * y * y;\n    }\n    SPLINE_POSITION[NB_SAMPLES] = SPLINE_TIME[NB_SAMPLES] = 1.0;\n})();\n\nfunction signum (number) {\n    if (isNaN(number)) {\n        return NaN;\n    }\n    var sig = number;\n    if (number > 0) {\n        sig = 1;\n    } else if (number < 0) {\n        sig = -1;\n    }\n    return sig;\n}\n\nexport default class Scroller {\n  /**\n   *\n   * @param flywheel specify whether or not to support progressive \"flywheel\" behavior in flinging.\n   */\n    constructor (flywheel, onScrollCallback) {\n        this.mCurrX = 0;\n        this.mCurrY = 0;\n        this.mFinished = true;\n        this.mInterpolator = ViscousFluidInterpolator;\n    // this.mPpi = PixelRatio.get() * 160;\n        this.mPpi = 160;\n        this.mDeceleration = this.computeDeceleration(SCROLL_FRICTION);\n        this.mFlywheel = flywheel;\n\n        this.mPhysicalCoeff = this.computeDeceleration(0.84); // look and feel tuning\n\n        this.mFlingFriction = SCROLL_FRICTION;\n        this.onScrollCallback = onScrollCallback;\n    }\n\n    computeDeceleration (friction) {\n        return GRAVITY_EARTH * 39.37 * this.mPpi * friction;\n    }\n\n  /**\n   * Returns whether the scroller has finished scrolling.\n   * @returns {Boolean} True if the scroller has finished scrolling, false otherwise.\n   */\n    isFinished () {\n        return this.mFinished;\n    }\n\n  /**\n   * Force the finished field to a particular value.\n   * @param finished The new finished value.\n   */\n    forceFinished (finished) {\n        this.mFinished = finished;\n    }\n\n  /**\n   * Returns the current X offset in the scroll.\n   * @returns {*} The new X offset as an absolute distance from the origin.\n   */\n    getCurrX () {\n        return this.mCurrX;\n    }\n\n  /**\n   * Returns the current Y offset in the scroll.\n   * @returns {*} The new Y offset as an absolute distance from the origin.\n   */\n    getCurrY () {\n        return this.mCurrY;\n    }\n\n    getCurrVelocity () {\n        return this.mMode === FLING_MODE ?\n      this.mCurrVelocity : this.mVelocity - this.mDeceleration * this.timePassed() / 2000.0;\n    }\n\n    computeScrollOffset () {\n        if (this.mFinished) {\n            this.onScrollCallback && this.onScrollCallback(0, 0, this);\n            return false;\n        }\n\n        var timePassed = currentAnimationTimeMillis() - this.mStartTime;\n\n        if (timePassed < this.mDuration) {\n            switch (this.mMode) {\n            case SCROLL_MODE:\n                let x = this.mInterpolator.getInterpolation(timePassed * this.mDurationReciprocal);\n                this.mCurrX = this.mStartX + Math.round(x * this.mDeltaX);\n                this.mCurrY = this.mStartY + Math.round(x * this.mDeltaY);\n                break;\n            case FLING_MODE:\n                let t = timePassed / this.mDuration;\n                let index = parseInt(NB_SAMPLES * t);\n                let distanceCoef = 1;\n                let velocityCoef = 0;\n                if (index < NB_SAMPLES) {\n                    let t_inf = index / NB_SAMPLES;\n                    let t_sup = (index + 1) / NB_SAMPLES;\n                    let d_inf = SPLINE_POSITION[index];\n                    let d_sup = SPLINE_POSITION[index + 1];\n                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);\n                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;\n                }\n\n                this.mCurrVelocity = velocityCoef * this.mDistance / this.mDuration * 1000;\n\n                this.mCurrX = this.mStartX + Math.round(distanceCoef * (this.mFinalX - this.mStartX));\n          // Pin to mMinX <= mCurrX <= mMaxX\n          // this.mCurrX = Math.min(this.mCurrX, this.mMaxX);\n          // this.mCurrX = Math.max(this.mCurrX, this.mMinX);\n\n                this.mCurrY = this.mStartY + Math.round(distanceCoef * (this.mFinalY - this.mStartY));\n          // Pin to mMinY <= mCurrY <= mMaxY\n                this.mCurrY = Math.min(this.mCurrY, this.mMaxY);\n                this.mCurrY = Math.max(this.mCurrY, this.mMinY);\n\n                if (this.mCurrX == this.mFinalX && this.mCurrY == this.mFinalY) {\n                    this.mFinished = true;\n                }\n\n                break;\n            }\n        } else {\n            this.mCurrX = this.mFinalX;\n            this.mCurrY = this.mFinalY;\n            this.mFinished = true;\n        }\n\n        var dx = this.mCurrX - this.mLastX;\n        var dy = this.mCurrY - this.mLastY;\n\n        this.mLastX = this.mCurrX;\n        this.mLastY = this.mCurrY;\n\n        this.onScrollCallback && this.onScrollCallback(dx, dy, this);\n\n        if (dx === 0 && dy === 0 && this.mFinished) {\n            return false;\n        }\n        return true;\n    }\n\n    startScroll (startX, startY, dx, dy, duration = DEFAULT_DURATION) {\n        this.mMode = SCROLL_MODE;\n        this.mFinished = false;\n        this.mDuration = duration;\n        this.mStartTime = currentAnimationTimeMillis();\n        this.mStartX = startX;\n        this.mStartY = startY;\n        this.mFinalX = startX + dx;\n        this.mFinalY = startY + dy;\n        this.mDeltaX = dx;\n        this.mDeltaY = dy;\n        this.mDurationReciprocal = 1.0 / this.mDuration;\n\n        this.mLastX = this.mStartX;\n        this.mLastY = this.mStartY;\n\n        this.performAnimation();\n    }\n\n  /**\n   * Start scrolling based on a fling gesture. The distance travelled will\n   * depend on the initial velocity of the fling.\n   * @param startX\n   * @param startY\n   * @param velocityX Initial velocity of the fling (X) measured in dp or pt per second\n   * @param velocityY Initial velocity of the fling (Y) measured in dp or pt per second\n   * @param minX\n   * @param maxX\n   * @param minY\n   * @param maxY\n   */\n    fling (startX, startY, velocityX, velocityY,\n        minX, maxX, minY, maxY) {\n    // Continue a scroll or fling in progress\n        if (this.mFlywheel && !this.mFinished) {\n            let oldVel = this.getCurrVelocity();\n\n            let dx = this.mFinalX - this.mStartX;\n            let dy = this.mFinalY - this.mStartY;\n            let hyp = Math.hypot(dx, dy);\n\n            let ndx = dx / hyp;\n            let ndy = dy / hyp;\n\n            let oldVelocityX = ndx * oldVel;\n            let oldVelocityY = ndy * oldVel;\n            if (signum(velocityX) === signum(oldVelocityX) &&\n        signum(velocityY) === signum(oldVelocityY)) {\n                velocityX += oldVelocityX;\n                velocityY += oldVelocityY;\n            }\n        }\n\n        this.mMode = FLING_MODE;\n        this.mFinished = false;\n\n        let velocity = Math.hypot(velocityX, velocityY);\n\n        this.mVelocity = velocity;\n        this.mDuration = this.getSplineFlingDuration(velocity);\n        this.mStartTime = currentAnimationTimeMillis();\n        this.mStartX = startX;\n        this.mStartY = startY;\n\n        let coeffX = velocity == 0 ? 1.0 : velocityX / velocity;\n        let coeffY = velocity == 0 ? 1.0 : velocityY / velocity;\n\n        let totalDistance = this.getSplineFlingDistance(velocity);\n        this.mDistance = totalDistance * signum(velocity);\n\n        this.mMinX = minX;\n        this.mMaxX = maxX;\n        this.mMinY = minY;\n        this.mMaxY = maxY;\n\n        this.mFinalX = startX + Math.round(totalDistance * coeffX);\n    // Pin to mMinX <= mFinalX <= mMaxX\n        this.mFinalX = Math.min(this.mFinalX, this.mMaxX);\n        this.mFinalX = Math.max(this.mFinalX, this.mMinX);\n\n        this.mFinalY = startY + Math.round(totalDistance * coeffY);\n    // Pin to mMinY <= mFinalY <= mMaxY\n        this.mFinalY = Math.min(this.mFinalY, this.mMaxY);\n        this.mFinalY = Math.max(this.mFinalY, this.mMinY);\n\n        this.mLastX = this.mStartX;\n        this.mLastY = this.mStartY;\n\n        this.performAnimation();\n    }\n\n    getSplineDeceleration (velocity) {\n        return Math.log(INFLEXION * Math.abs(velocity) / (this.mFlingFriction * this.mPhysicalCoeff));\n    }\n\n    getSplineFlingDuration (velocity) {\n        var l = this.getSplineDeceleration(velocity);\n        var decelMinusOne = DECELERATION_RATE - 1.0;\n        return 1000.0 * Math.exp(l / decelMinusOne);\n    }\n\n    getSplineFlingDistance (velocity) {\n        var l = this.getSplineDeceleration(velocity);\n        var decelMinusOne = DECELERATION_RATE - 1.0;\n        return this.mFlingFriction * this.mPhysicalCoeff * Math.exp(DECELERATION_RATE / decelMinusOne * l);\n    }\n\n    performAnimation () {\n        if (this.computeScrollOffset()) {\n            requestAnimationFrame(this.performAnimation.bind(this));\n        } else {\n        }\n    }\n\n    abortAnimation () {\n        this.mCurrX = this.mFinalX;\n        this.mCurrY = this.mFinalY;\n        this.mFinished = true;\n    }\n\n    extendDuration (extend) {\n        var passed = timePassed();\n        this.mDuration = passed + extend;\n        this.mDurationReciprocal = 1.0 / this.mDuration;\n        this.mFinished = false;\n    }\n\n    timePassed () {\n        return currentAnimationTimeMillis() - this.mStartTime;\n    }\n\n    setFinalX (newX) {\n        this.mFinalX = newX;\n        this.mDeltaX = this.mFinalX - this.mStartX;\n        this.mFinished = false;\n    }\n\n    setFinalY (newY) {\n        this.mFinalY = newY;\n        this.mDeltaY = this.mFinalY - this.mStartY;\n        this.mFinished = false;\n    }\n\n    debugInfo () {\n        return 'cur=' + this.mCurrX + ' ' + this.mCurrY + ', final=' + this.mFinalX + ' ' + this.mFinalY;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}