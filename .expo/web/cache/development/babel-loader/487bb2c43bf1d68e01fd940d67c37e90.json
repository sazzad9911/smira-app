{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { PureComponent } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport FlatList from \"react-native-web/dist/exports/FlatList\";\nimport { ViewPropTypes } from \"react-native-web/dist/index\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport PropTypes from 'prop-types';\nimport Scroller from \"../Scroller\";\nimport { createResponder } from \"../GestureResponder\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar MIN_FLING_VELOCITY = 0.5;\n\nvar _Dimensions$get = Dimensions.get('window'),\n    width = _Dimensions$get.width,\n    height = _Dimensions$get.height;\n\nvar ViewPager = function (_PureComponent) {\n  _inherits(ViewPager, _PureComponent);\n\n  var _super = _createSuper(ViewPager);\n\n  function ViewPager(props) {\n    var _this;\n\n    _classCallCheck(this, ViewPager);\n\n    _this = _super.call(this, props);\n    _this.currentPage = undefined;\n    _this.layoutChanged = false;\n    _this.activeGesture = false;\n    _this.gestureResponder = undefined;\n    _this.state = {\n      width: width,\n      height: height\n    };\n    _this.onLayout = _this.onLayout.bind(_assertThisInitialized(_this));\n    _this.renderRow = _this.renderRow.bind(_assertThisInitialized(_this));\n    _this.onResponderGrant = _this.onResponderGrant.bind(_assertThisInitialized(_this));\n    _this.onResponderMove = _this.onResponderMove.bind(_assertThisInitialized(_this));\n    _this.onResponderRelease = _this.onResponderRelease.bind(_assertThisInitialized(_this));\n    _this.getItemLayout = _this.getItemLayout.bind(_assertThisInitialized(_this));\n    _this.scroller = _this.createScroller();\n    return _this;\n  }\n\n  _createClass(ViewPager, [{\n    key: \"createScroller\",\n    value: function createScroller() {\n      var _this2 = this;\n\n      return new Scroller(true, function (dx, dy, scroller) {\n        if (dx === 0 && dy === 0 && scroller.isFinished()) {\n          if (!_this2.activeGesture) {\n            _this2.onPageScrollStateChanged('idle');\n          }\n        } else {\n          var curX = _this2.scroller.getCurrX();\n\n          _this2.refs['innerFlatList'] && _this2.refs['innerFlatList'].scrollToOffset({\n            offset: curX,\n            animated: false\n          });\n          var position = Math.floor(curX / (_this2.state.width + _this2.props.pageMargin));\n          position = _this2.validPage(position);\n\n          var offset = (curX - _this2.getScrollOffsetOfPage(position)) / (_this2.state.width + _this2.props.pageMargin);\n\n          var fraction = (curX - _this2.getScrollOffsetOfPage(position) - _this2.props.pageMargin) / _this2.state.width;\n\n          if (fraction < 0) {\n            fraction = 0;\n          }\n\n          _this2.props.onPageScroll && _this2.props.onPageScroll({\n            position: position,\n            offset: offset,\n            fraction: fraction\n          });\n        }\n      });\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      this.gestureResponder = createResponder({\n        onStartShouldSetResponder: function onStartShouldSetResponder(evt, gestureState) {\n          return true;\n        },\n        onResponderGrant: this.onResponderGrant,\n        onResponderMove: this.onResponderMove,\n        onResponderRelease: this.onResponderRelease,\n        onResponderTerminate: this.onResponderRelease\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this3 = this;\n\n      this.onPageScrollStateChanged('settling');\n      var page = this.validPage(this.props.initialPage);\n      this.onPageChanged(page);\n      var finalX = this.getScrollOffsetOfPage(page);\n      this.scroller.startScroll(this.scroller.getCurrX(), 0, finalX - this.scroller.getCurrX(), 0, 0);\n      requestAnimationFrame(function () {\n        _this3.scrollByOffset(1);\n\n        _this3.scrollByOffset(-1);\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.layoutChanged) {\n        this.layoutChanged = false;\n\n        if (typeof this.currentPage === 'number') {\n          this.scrollToPage(this.currentPage, true);\n        }\n      } else if (this.currentPage + 1 >= this.props.pageDataArray.length && this.props.pageDataArray.length !== prevProps.pageDataArray.length) {\n        this.scrollToPage(this.props.pageDataArray.length, true);\n      }\n    }\n  }, {\n    key: \"onLayout\",\n    value: function onLayout(e) {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n          width = _e$nativeEvent$layout.width,\n          height = _e$nativeEvent$layout.height;\n      var sizeChanged = this.state.width !== width || this.state.height !== height;\n\n      if (width && height && sizeChanged) {\n        this.layoutChanged = true;\n        this.setState({\n          width: width,\n          height: height\n        });\n      }\n    }\n  }, {\n    key: \"onResponderGrant\",\n    value: function onResponderGrant(evt, gestureState) {\n      this.activeGesture = true;\n      this.onPageScrollStateChanged('dragging');\n    }\n  }, {\n    key: \"onResponderMove\",\n    value: function onResponderMove(evt, gestureState) {\n      var dx = gestureState.moveX - gestureState.previousMoveX;\n      this.scrollByOffset(dx);\n    }\n  }, {\n    key: \"onResponderRelease\",\n    value: function onResponderRelease(evt, gestureState, disableSettle) {\n      this.activeGesture = false;\n\n      if (!disableSettle) {\n        this.settlePage(gestureState.vx);\n      }\n    }\n  }, {\n    key: \"onPageChanged\",\n    value: function onPageChanged(page) {\n      if (this.currentPage !== page) {\n        this.currentPage = page;\n        this.props.onPageSelected && this.props.onPageSelected(page);\n      }\n    }\n  }, {\n    key: \"onPageScrollStateChanged\",\n    value: function onPageScrollStateChanged(state) {\n      this.props.onPageScrollStateChanged && this.props.onPageScrollStateChanged(state);\n    }\n  }, {\n    key: \"settlePage\",\n    value: function settlePage(vx) {\n      var pageDataArray = this.props.pageDataArray;\n\n      if (vx < -MIN_FLING_VELOCITY) {\n        if (this.currentPage < pageDataArray.length - 1) {\n          this.flingToPage(this.currentPage + 1, vx);\n        } else {\n          this.flingToPage(pageDataArray.length - 1, vx);\n        }\n      } else if (vx > MIN_FLING_VELOCITY) {\n        if (this.currentPage > 0) {\n          this.flingToPage(this.currentPage - 1, vx);\n        } else {\n          this.flingToPage(0, vx);\n        }\n      } else {\n        var page = this.currentPage;\n        var progress = (this.scroller.getCurrX() - this.getScrollOffsetOfPage(this.currentPage)) / this.state.width;\n\n        if (progress > 1 / 3) {\n          page += 1;\n        } else if (progress < -1 / 3) {\n          page -= 1;\n        }\n\n        page = Math.min(pageDataArray.length - 1, page);\n        page = Math.max(0, page);\n        this.scrollToPage(page);\n      }\n    }\n  }, {\n    key: \"getScrollOffsetOfPage\",\n    value: function getScrollOffsetOfPage(page) {\n      return this.getItemLayout(this.props.pageDataArray, page).offset;\n    }\n  }, {\n    key: \"flingToPage\",\n    value: function flingToPage(page, velocityX) {\n      this.onPageScrollStateChanged('settling');\n      page = this.validPage(page);\n      this.onPageChanged(page);\n      velocityX *= -1000;\n      var finalX = this.getScrollOffsetOfPage(page);\n      this.scroller.fling(this.scroller.getCurrX(), 0, velocityX, 0, finalX, finalX, 0, 0);\n    }\n  }, {\n    key: \"scrollToPage\",\n    value: function scrollToPage(page, immediate) {\n      var _this4 = this;\n\n      this.onPageScrollStateChanged('settling');\n      page = this.validPage(page);\n      this.onPageChanged(page);\n      var finalX = this.getScrollOffsetOfPage(page);\n\n      if (immediate) {\n        InteractionManager.runAfterInteractions(function () {\n          _this4.scroller.startScroll(_this4.scroller.getCurrX(), 0, finalX - _this4.scroller.getCurrX(), 0, 0);\n\n          _this4.refs['innerFlatList'] && _this4.refs['innerFlatList'].scrollToOffset({\n            offset: finalX,\n            animated: false\n          });\n          _this4.refs['innerFlatList'] && _this4.refs['innerFlatList'].recordInteraction();\n        });\n      } else {\n        this.scroller.startScroll(this.scroller.getCurrX(), 0, finalX - this.scroller.getCurrX(), 0, 400);\n      }\n    }\n  }, {\n    key: \"scrollByOffset\",\n    value: function scrollByOffset(dx) {\n      this.scroller.startScroll(this.scroller.getCurrX(), 0, -dx, 0, 0);\n    }\n  }, {\n    key: \"validPage\",\n    value: function validPage(page) {\n      page = Math.min(this.props.pageDataArray.length - 1, page);\n      page = Math.max(0, page);\n      return page;\n    }\n  }, {\n    key: \"getScrollOffsetFromCurrentPage\",\n    value: function getScrollOffsetFromCurrentPage() {\n      return this.scroller.getCurrX() - this.getScrollOffsetOfPage(this.currentPage);\n    }\n  }, {\n    key: \"getItemLayout\",\n    value: function getItemLayout(data, index) {\n      return {\n        length: this.state.width + this.props.pageMargin,\n        offset: (this.state.width + this.props.pageMargin) * index,\n        index: index\n      };\n    }\n  }, {\n    key: \"keyExtractor\",\n    value: function keyExtractor(item, index) {\n      return index;\n    }\n  }, {\n    key: \"renderRow\",\n    value: function renderRow(_ref) {\n      var item = _ref.item,\n          index = _ref.index;\n      var _this$state = this.state,\n          width = _this$state.width,\n          height = _this$state.height;\n      var page = this.props.renderPage(item, index);\n      var layout = {\n        width: width,\n        height: height,\n        position: 'relative'\n      };\n      var style = page.props.style ? [page.props.style, layout] : layout;\n\n      var newProps = _objectSpread(_objectSpread({}, page.props), {}, {\n        ref: page.ref,\n        style: style\n      });\n\n      var element = React.createElement(page.type, newProps);\n\n      if (this.props.pageMargin > 0 && index > 0) {\n        return _jsx(View, {\n          style: {\n            width: width + this.props.pageMargin,\n            height: height,\n            alignItems: 'flex-end'\n          },\n          children: element\n        });\n      } else {\n        return element;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state2 = this.state,\n          width = _this$state2.width,\n          height = _this$state2.height;\n      var _this$props = this.props,\n          pageDataArray = _this$props.pageDataArray,\n          scrollEnabled = _this$props.scrollEnabled,\n          style = _this$props.style,\n          scrollViewStyle = _this$props.scrollViewStyle;\n\n      if (width && height) {\n        var list = pageDataArray;\n\n        if (!list) {\n          list = [];\n        }\n      }\n\n      var gestureResponder = this.gestureResponder;\n\n      if (!scrollEnabled || pageDataArray.length <= 0) {\n        gestureResponder = {};\n      }\n\n      return _jsx(View, _objectSpread(_objectSpread(_objectSpread({}, this.props), {}, {\n        style: [style, {\n          flex: 1\n        }]\n      }, gestureResponder), {}, {\n        children: _jsx(FlatList, _objectSpread(_objectSpread({}, this.props.flatListProps), {}, {\n          style: [{\n            flex: 1\n          }, scrollViewStyle],\n          ref: 'innerFlatList',\n          keyExtractor: this.keyExtractor,\n          scrollEnabled: false,\n          horizontal: true,\n          data: pageDataArray,\n          renderItem: this.renderRow,\n          onLayout: this.onLayout,\n          contentOffset: {\n            x: this.getScrollOffsetOfPage(parseInt(this.props.initialPage)),\n            y: 0\n          }\n        }))\n      }));\n    }\n  }]);\n\n  return ViewPager;\n}(PureComponent);\n\nViewPager.propTypes = _objectSpread(_objectSpread({}, View.propTypes), {}, {\n  initialPage: PropTypes.number,\n  pageMargin: PropTypes.number,\n  scrollViewStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n  scrollEnabled: PropTypes.bool,\n  renderPage: PropTypes.func,\n  pageDataArray: PropTypes.array,\n  initialListSize: PropTypes.number,\n  removeClippedSubviews: PropTypes.bool,\n  onPageSelected: PropTypes.func,\n  onPageScrollStateChanged: PropTypes.func,\n  onPageScroll: PropTypes.func,\n  flatListProps: PropTypes.object\n});\nViewPager.defaultProps = {\n  initialPage: 0,\n  pageMargin: 0,\n  scrollEnabled: true,\n  pageDataArray: [],\n  initialListSize: 10,\n  removeClippedSubviews: true,\n  flatListProps: {}\n};\nexport { ViewPager as default };","map":{"version":3,"sources":["C:/Users/takia/OneDrive/Desktop/Data/Projects/mobile_app/mobile_app/Handoff/node_modules/react-native-image-gallery/src/libraries/ViewPager/index.js"],"names":["React","PureComponent","ViewPropTypes","PropTypes","Scroller","createResponder","MIN_FLING_VELOCITY","Dimensions","get","width","height","ViewPager","props","currentPage","undefined","layoutChanged","activeGesture","gestureResponder","state","onLayout","bind","renderRow","onResponderGrant","onResponderMove","onResponderRelease","getItemLayout","scroller","createScroller","dx","dy","isFinished","onPageScrollStateChanged","curX","getCurrX","refs","scrollToOffset","offset","animated","position","Math","floor","pageMargin","validPage","getScrollOffsetOfPage","fraction","onPageScroll","onStartShouldSetResponder","evt","gestureState","onResponderTerminate","page","initialPage","onPageChanged","finalX","startScroll","requestAnimationFrame","scrollByOffset","prevProps","scrollToPage","pageDataArray","length","e","nativeEvent","layout","sizeChanged","setState","moveX","previousMoveX","disableSettle","settlePage","vx","onPageSelected","flingToPage","progress","min","max","velocityX","fling","immediate","InteractionManager","runAfterInteractions","recordInteraction","data","index","item","renderPage","style","newProps","ref","element","createElement","type","alignItems","scrollEnabled","scrollViewStyle","list","flex","flatListProps","keyExtractor","x","parseInt","y","propTypes","View","number","bool","func","array","initialListSize","removeClippedSubviews","object","defaultProps"],"mappings":"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","sourcesContent":["import React, { PureComponent } from 'react';\nimport {\n    View,\n    FlatList,\n    ViewPropTypes,\n    InteractionManager,\n    Dimensions\n} from 'react-native';\nimport PropTypes from 'prop-types';\nimport Scroller from '../Scroller';\nimport { createResponder } from '../GestureResponder';\n\nconst MIN_FLING_VELOCITY = 0.5;\n\n// Dimensions are only used initially.\n// onLayout should handle orientation swap.\nconst { width, height } = Dimensions.get('window');\n\nexport default class ViewPager extends PureComponent {\n    static propTypes = {\n        ...View.propTypes,\n        initialPage: PropTypes.number,\n        pageMargin: PropTypes.number,\n        scrollViewStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        scrollEnabled: PropTypes.bool,\n        renderPage: PropTypes.func,\n        pageDataArray: PropTypes.array,\n        initialListSize: PropTypes.number,\n        removeClippedSubviews: PropTypes.bool,\n        onPageSelected: PropTypes.func,\n        onPageScrollStateChanged: PropTypes.func,\n        onPageScroll: PropTypes.func,\n        flatListProps: PropTypes.object\n    };\n\n    static defaultProps = {\n        initialPage: 0,\n        pageMargin: 0,\n        scrollEnabled: true,\n        pageDataArray: [],\n        initialListSize: 10,\n        removeClippedSubviews: true,\n        flatListProps: {}\n    };\n\n    currentPage = undefined; // Do not initialize to make onPageSelected(0) be dispatched\n    layoutChanged = false;\n    activeGesture = false;\n    gestureResponder = undefined;\n\n    state = { width, height };\n\n    constructor (props) {\n        super(props);\n\n        this.onLayout = this.onLayout.bind(this);\n        this.renderRow = this.renderRow.bind(this);\n        this.onResponderGrant = this.onResponderGrant.bind(this);\n        this.onResponderMove = this.onResponderMove.bind(this);\n        this.onResponderRelease = this.onResponderRelease.bind(this);\n        this.getItemLayout = this.getItemLayout.bind(this);\n\n        this.scroller = this.createScroller();\n    }\n\n    createScroller () {\n        return new Scroller(true, (dx, dy, scroller) => {\n            if (dx === 0 && dy === 0 && scroller.isFinished()) {\n                if (!this.activeGesture) {\n                    this.onPageScrollStateChanged('idle');\n                }\n            } else {\n                const curX = this.scroller.getCurrX();\n                this.refs['innerFlatList'] && this.refs['innerFlatList'].scrollToOffset({ offset: curX, animated: false });\n\n                let position = Math.floor(curX / (this.state.width + this.props.pageMargin));\n                position = this.validPage(position);\n                let offset = (curX - this.getScrollOffsetOfPage(position)) / (this.state.width + this.props.pageMargin);\n                let fraction = (curX - this.getScrollOffsetOfPage(position) - this.props.pageMargin) / this.state.width;\n                if (fraction < 0) {\n                    fraction = 0;\n                }\n                this.props.onPageScroll && this.props.onPageScroll({\n                    position, offset, fraction\n                });\n            }\n        });\n    }\n\n    componentWillMount () {\n        this.gestureResponder = createResponder({\n            onStartShouldSetResponder: (evt, gestureState) => true,\n            onResponderGrant: this.onResponderGrant,\n            onResponderMove: this.onResponderMove,\n            onResponderRelease: this.onResponderRelease,\n            onResponderTerminate: this.onResponderRelease\n        });\n    }\n\n    componentDidMount () {\n        // FlatList is set to render at initialPage.\n        // The scroller we use is not aware of this.\n        // Let it know by simulating most of what happens in scrollToPage()\n        this.onPageScrollStateChanged('settling');\n\n        const page = this.validPage(this.props.initialPage);\n        this.onPageChanged(page);\n\n        const finalX = this.getScrollOffsetOfPage(page);\n        this.scroller.startScroll(this.scroller.getCurrX(), 0, finalX - this.scroller.getCurrX(), 0, 0);\n        \n        requestAnimationFrame(() => {\n            // this is here to work around a bug in FlatList, as discussed here\n            // https://github.com/facebook/react-native/issues/1831\n            // (and solved here https://github.com/facebook/react-native/commit/03ae65bc ?)\n            this.scrollByOffset(1);\n            this.scrollByOffset(-1);\n        });\n    }\n\n    componentDidUpdate (prevProps) {\n        if (this.layoutChanged) {\n            this.layoutChanged = false;\n            if (typeof this.currentPage === 'number') {\n                this.scrollToPage(this.currentPage, true);\n            }\n        } else if (this.currentPage + 1 >= this.props.pageDataArray.length &&\n            this.props.pageDataArray.length !== prevProps.pageDataArray.length) {\n            this.scrollToPage(this.props.pageDataArray.length, true);\n        }\n    }\n\n    onLayout (e) {\n        let { width, height } = e.nativeEvent.layout;\n        let sizeChanged = this.state.width !== width || this.state.height !== height;\n        if (width && height && sizeChanged) {\n            this.layoutChanged = true;\n            this.setState({ width, height });\n        }\n    }\n\n    onResponderGrant (evt, gestureState) {\n        // this.scroller.forceFinished(true);\n        this.activeGesture = true;\n        this.onPageScrollStateChanged('dragging');\n    }\n\n    onResponderMove (evt, gestureState) {\n        let dx = gestureState.moveX - gestureState.previousMoveX;\n        this.scrollByOffset(dx);\n    }\n\n    onResponderRelease (evt, gestureState, disableSettle) {\n        this.activeGesture = false;\n        if (!disableSettle) {\n            this.settlePage(gestureState.vx);\n        }\n    }\n\n    onPageChanged (page) {\n        if (this.currentPage !== page) {\n            this.currentPage = page;\n            this.props.onPageSelected && this.props.onPageSelected(page);\n        }\n    }\n\n    onPageScrollStateChanged (state) {\n        this.props.onPageScrollStateChanged && this.props.onPageScrollStateChanged(state);\n    }\n\n    settlePage (vx) {\n        const { pageDataArray } = this.props;\n\n        if (vx < -MIN_FLING_VELOCITY) {\n            if (this.currentPage < pageDataArray.length - 1) {\n                this.flingToPage(this.currentPage + 1, vx);\n            } else {\n                this.flingToPage(pageDataArray.length - 1, vx);\n            }\n        } else if (vx > MIN_FLING_VELOCITY) {\n            if (this.currentPage > 0) {\n                this.flingToPage(this.currentPage - 1, vx);\n            } else {\n                this.flingToPage(0, vx);\n            }\n        } else {\n            let page = this.currentPage;\n            let progress = (this.scroller.getCurrX() - this.getScrollOffsetOfPage(this.currentPage)) / this.state.width;\n            if (progress > 1 / 3) {\n                page += 1;\n            } else if (progress < -1 / 3) {\n                page -= 1;\n            }\n            page = Math.min(pageDataArray.length - 1, page);\n            page = Math.max(0, page);\n            this.scrollToPage(page);\n        }\n    }\n\n    getScrollOffsetOfPage (page) {\n        return this.getItemLayout(this.props.pageDataArray, page).offset;\n    }\n\n    flingToPage (page, velocityX) {\n        this.onPageScrollStateChanged('settling');\n\n        page = this.validPage(page);\n        this.onPageChanged(page);\n\n        velocityX *= -1000; // per sec\n        const finalX = this.getScrollOffsetOfPage(page);\n        this.scroller.fling(this.scroller.getCurrX(), 0, velocityX, 0, finalX, finalX, 0, 0);\n    }\n\n    scrollToPage (page, immediate) {\n        this.onPageScrollStateChanged('settling');\n\n        page = this.validPage(page);\n        this.onPageChanged(page);\n\n        const finalX = this.getScrollOffsetOfPage(page);\n        if (immediate) {\n            InteractionManager.runAfterInteractions(() => {\n                this.scroller.startScroll(this.scroller.getCurrX(), 0, finalX - this.scroller.getCurrX(), 0, 0);\n                this.refs['innerFlatList'] && this.refs['innerFlatList'].scrollToOffset({offset: finalX, animated: false});\n                this.refs['innerFlatList'] && this.refs['innerFlatList'].recordInteraction();\n            });\n        } else {\n            this.scroller.startScroll(this.scroller.getCurrX(), 0, finalX - this.scroller.getCurrX(), 0, 400);\n        }\n    }\n\n    scrollByOffset (dx) {\n        this.scroller.startScroll(this.scroller.getCurrX(), 0, -dx, 0, 0);\n    }\n\n    validPage (page) {\n        page = Math.min(this.props.pageDataArray.length - 1, page);\n        page = Math.max(0, page);\n        return page;\n    }\n\n    getScrollOffsetFromCurrentPage () {\n        return this.scroller.getCurrX() - this.getScrollOffsetOfPage(this.currentPage);\n    }\n\n    getItemLayout (data, index) {\n        // this method is called 'getItemLayout', but it is not actually used\n        // as the 'getItemLayout' function for the FlatList. We use it within\n        // the code on this page though. The reason for this is that working\n        // with 'getItemLayout' for FlatList is buggy. You might end up with\n        // unrendered / missing content. Therefore we work around it, as\n        // described here\n        // https://github.com/facebook/react-native/issues/15734#issuecomment-330616697\n        return {\n            length: this.state.width + this.props.pageMargin,\n            offset: (this.state.width + this.props.pageMargin) * index,\n            index\n        };\n    }\n\n    keyExtractor (item, index) {\n        return index;\n    }\n\n    renderRow ({ item, index }) {\n        const { width, height } = this.state;\n        let page = this.props.renderPage(item, index);\n\n        const layout = {\n            width,\n            height,\n            position: 'relative'\n        };\n        const style = page.props.style ? [page.props.style, layout] : layout;\n\n        let newProps = { ...page.props, ref: page.ref, style };\n        const element = React.createElement(page.type, newProps);\n\n        if (this.props.pageMargin > 0 && index > 0) {\n            // Do not using margin style to implement pageMargin.\n            // The ListView seems to calculate a wrong width for children views with margin.\n            return (\n                <View style={{\n                    width: width + this.props.pageMargin,\n                    height: height,\n                    alignItems: 'flex-end'\n                }}>\n                    { element }\n                </View>\n            );\n        } else {\n            return element;\n        }\n    }\n\n    render () {\n        const { width, height } = this.state;\n        const { pageDataArray, scrollEnabled, style, scrollViewStyle } = this.props;\n\n        if (width && height) {\n            let list = pageDataArray;\n            if (!list) {\n                list = [];\n            }\n        }\n\n        let gestureResponder = this.gestureResponder;\n        if (!scrollEnabled || pageDataArray.length <= 0) {\n            gestureResponder = {};\n        }\n\n        return (\n            <View\n              {...this.props}\n              style={[style, { flex: 1 }]}\n              {...gestureResponder}>\n                <FlatList\n                  {...this.props.flatListProps}\n                  style={[{ flex: 1 }, scrollViewStyle]}\n                  ref={'innerFlatList'}\n                  keyExtractor={this.keyExtractor}\n                  scrollEnabled={false}\n                  horizontal={true}\n                  data={pageDataArray}\n                  renderItem={this.renderRow}\n                  onLayout={this.onLayout}\n\n                  // use contentOffset instead of initialScrollIndex so that we don't have\n                  // to use the buggy 'getItemLayout' prop. See\n                  // https://github.com/facebook/react-native/issues/15734#issuecomment-330616697 and\n                  // https://github.com/facebook/react-native/issues/14945#issuecomment-354651271\n                  contentOffset = {{x: this.getScrollOffsetOfPage(parseInt(this.props.initialPage)), y:0}}\n              />\n            </View>\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}