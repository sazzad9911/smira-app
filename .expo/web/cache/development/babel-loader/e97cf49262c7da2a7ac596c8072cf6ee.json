{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport ReactNative from \"react-native-web/dist/index\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport Scroller from \"../Scroller\";\nimport PropTypes from 'prop-types';\nimport { createResponder } from \"../GestureResponder\";\nimport { Rect, Transform, transformedRect, availableTranslateSpace, fitCenterRect, alignedRect, getTransform } from \"./TransformUtils\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nvar ViewTransformer = function (_React$Component) {\n  _inherits(ViewTransformer, _React$Component);\n\n  var _super = _createSuper(ViewTransformer);\n\n  function ViewTransformer(props) {\n    var _this;\n\n    _classCallCheck(this, ViewTransformer);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      scale: 1,\n      translateX: 0,\n      translateY: 0,\n      animator: new Animated.Value(0),\n      width: 0,\n      height: 0,\n      pageX: 0,\n      pageY: 0\n    };\n    _this._viewPortRect = new Rect();\n    _this.onLayout = _this.onLayout.bind(_assertThisInitialized(_this));\n    _this.cancelAnimation = _this.cancelAnimation.bind(_assertThisInitialized(_this));\n    _this.contentRect = _this.contentRect.bind(_assertThisInitialized(_this));\n    _this.transformedContentRect = _this.transformedContentRect.bind(_assertThisInitialized(_this));\n    _this.animate = _this.animate.bind(_assertThisInitialized(_this));\n    _this.scroller = new Scroller(true, function (dx, dy, scroller) {\n      if (dx === 0 && dy === 0 && scroller.isFinished()) {\n        _this.animateBounce();\n\n        return;\n      }\n\n      _this.updateTransform({\n        translateX: _this.state.translateX + dx / _this.state.scale,\n        translateY: _this.state.translateY + dy / _this.state.scale\n      });\n    });\n    return _this;\n  }\n\n  _createClass(ViewTransformer, [{\n    key: \"viewPortRect\",\n    value: function viewPortRect() {\n      this._viewPortRect.set(0, 0, this.state.width, this.state.height);\n\n      return this._viewPortRect;\n    }\n  }, {\n    key: \"contentRect\",\n    value: function contentRect() {\n      var rect = this.viewPortRect().copy();\n\n      if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n        rect = fitCenterRect(this.props.contentAspectRatio, rect);\n      }\n\n      return rect;\n    }\n  }, {\n    key: \"transformedContentRect\",\n    value: function transformedContentRect() {\n      var rect = transformedRect(this.viewPortRect(), this.currentTransform());\n\n      if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n        rect = fitCenterRect(this.props.contentAspectRatio, rect);\n      }\n\n      return rect;\n    }\n  }, {\n    key: \"currentTransform\",\n    value: function currentTransform() {\n      return new Transform(this.state.scale, this.state.translateX, this.state.translateY);\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      var _this2 = this;\n\n      this.gestureResponder = createResponder({\n        onStartShouldSetResponder: function onStartShouldSetResponder(evt, gestureState) {\n          return true;\n        },\n        onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(evt, gestureState) {\n          return true;\n        },\n        onResponderMove: this.onResponderMove,\n        onResponderGrant: this.onResponderGrant,\n        onResponderRelease: this.onResponderRelease,\n        onResponderTerminate: this.onResponderRelease,\n        onResponderTerminationRequest: function onResponderTerminationRequest(evt, gestureState) {\n          return false;\n        },\n        onResponderSingleTapConfirmed: function onResponderSingleTapConfirmed(evt, gestureState) {\n          _this2.props.onSingleTapConfirmed && _this2.props.onSingleTapConfirmed();\n        }\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      this.props.onViewTransformed && this.props.onViewTransformed({\n        scale: this.state.scale,\n        translateX: this.state.translateX,\n        translateY: this.state.translateY\n      });\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.cancelAnimation();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var gestureResponder = this.gestureResponder;\n\n      if (!this.props.enableTransform) {\n        gestureResponder = {};\n      }\n\n      return _jsx(View, _objectSpread(_objectSpread(_objectSpread({}, this.props), gestureResponder), {}, {\n        ref: 'innerViewRef',\n        onLayout: this.onLayout,\n        children: _jsx(View, {\n          style: {\n            flex: 1,\n            transform: [{\n              scale: this.state.scale\n            }, {\n              translateX: this.state.translateX\n            }, {\n              translateY: this.state.translateY\n            }]\n          },\n          children: this.props.children\n        })\n      }));\n    }\n  }, {\n    key: \"onLayout\",\n    value: function onLayout(e) {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n          width = _e$nativeEvent$layout.width,\n          height = _e$nativeEvent$layout.height;\n\n      if (width !== this.state.width || height !== this.state.height) {\n        this.setState({\n          width: width,\n          height: height\n        });\n      }\n\n      this.measureLayout();\n      this.props.onLayout && this.props.onLayout(e);\n    }\n  }, {\n    key: \"measureLayout\",\n    value: function measureLayout() {\n      var _this3 = this;\n\n      var handle = ReactNative.findNodeHandle(this.refs['innerViewRef']);\n      NativeModules.UIManager.measure(handle, function (x, y, width, height, pageX, pageY) {\n        if (typeof pageX === 'number' && typeof pageY === 'number') {\n          if (_this3.state.pageX !== pageX || _this3.state.pageY !== pageY) {\n            _this3.setState({\n              pageX: pageX,\n              pageY: pageY\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: \"onResponderGrant\",\n    value: function onResponderGrant(evt, gestureState) {\n      this.props.onTransformStart && this.props.onTransformStart();\n      this.setState({\n        responderGranted: true\n      });\n      this.measureLayout();\n    }\n  }, {\n    key: \"onResponderMove\",\n    value: function onResponderMove(evt, gestureState) {\n      this.cancelAnimation();\n      var dx = gestureState.moveX - gestureState.previousMoveX;\n      var dy = gestureState.moveY - gestureState.previousMoveY;\n\n      if (this.props.enableResistance) {\n        var d = this.applyResistance(dx, dy);\n        dx = d.dx;\n        dy = d.dy;\n      }\n\n      if (!this.props.enableTranslate) {\n        dx = dy = 0;\n      }\n\n      var transform = {};\n\n      if (gestureState.previousPinch && gestureState.pinch && this.props.enableScale) {\n        var scaleBy = gestureState.pinch / gestureState.previousPinch;\n        var pivotX = gestureState.moveX - this.state.pageX;\n        var pivotY = gestureState.moveY - this.state.pageY;\n        var rect = transformedRect(transformedRect(this.contentRect(), this.currentTransform()), new Transform(scaleBy, dx, dy, {\n          x: pivotX,\n          y: pivotY\n        }));\n        transform = getTransform(this.contentRect(), rect);\n      } else {\n        if (Math.abs(dx) > 2 * Math.abs(dy)) {\n          dy = 0;\n        } else if (Math.abs(dy) > 2 * Math.abs(dx)) {\n          dx = 0;\n        }\n\n        transform.translateX = this.state.translateX + dx / this.state.scale;\n        transform.translateY = this.state.translateY + dy / this.state.scale;\n      }\n\n      this.updateTransform(transform);\n      return true;\n    }\n  }, {\n    key: \"onResponderRelease\",\n    value: function onResponderRelease(evt, gestureState) {\n      var handled = this.props.onTransformGestureReleased && this.props.onTransformGestureReleased({\n        scale: this.state.scale,\n        translateX: this.state.translateX,\n        translateY: this.state.translateY\n      });\n\n      if (handled) {\n        return;\n      }\n\n      if (gestureState.doubleTapUp) {\n        if (!this.props.enableScale) {\n          this.animateBounce();\n          return;\n        }\n\n        var pivotX = 0;\n        var pivotY = 0;\n\n        if (gestureState.dx || gestureState.dy) {\n          pivotX = gestureState.moveX - this.state.pageX;\n          pivotY = gestureState.moveY - this.state.pageY;\n        } else {\n          pivotX = gestureState.x0 - this.state.pageX;\n          pivotY = gestureState.y0 - this.state.pageY;\n        }\n\n        this.performDoubleTapUp(pivotX, pivotY);\n      } else {\n        if (this.props.enableTranslate) {\n          this.performFling(gestureState.vx, gestureState.vy);\n        } else {\n          this.animateBounce();\n        }\n      }\n    }\n  }, {\n    key: \"performFling\",\n    value: function performFling(vx, vy) {\n      var startX = 0;\n      var startY = 0;\n      var maxX, minX, maxY, minY;\n      var availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n\n      if (vx > 0) {\n        minX = 0;\n\n        if (availablePanDistance.left > 0) {\n          maxX = availablePanDistance.left + this.props.maxOverScrollDistance;\n        } else {\n          maxX = 0;\n        }\n      } else {\n        maxX = 0;\n\n        if (availablePanDistance.right > 0) {\n          minX = -availablePanDistance.right - this.props.maxOverScrollDistance;\n        } else {\n          minX = 0;\n        }\n      }\n\n      if (vy > 0) {\n        minY = 0;\n\n        if (availablePanDistance.top > 0) {\n          maxY = availablePanDistance.top + this.props.maxOverScrollDistance;\n        } else {\n          maxY = 0;\n        }\n      } else {\n        maxY = 0;\n\n        if (availablePanDistance.bottom > 0) {\n          minY = -availablePanDistance.bottom - this.props.maxOverScrollDistance;\n        } else {\n          minY = 0;\n        }\n      }\n\n      vx *= 1000;\n      vy *= 1000;\n\n      if (Math.abs(vx) > 2 * Math.abs(vy)) {\n        vy = 0;\n      } else if (Math.abs(vy) > 2 * Math.abs(vx)) {\n        vx = 0;\n      }\n\n      this.scroller.fling(startX, startY, vx, vy, minX, maxX, minY, maxY);\n    }\n  }, {\n    key: \"performDoubleTapUp\",\n    value: function performDoubleTapUp(pivotX, pivotY) {\n      var curScale = this.state.scale;\n      var scaleBy;\n\n      if (curScale > (1 + this.props.maxScale) / 2) {\n        scaleBy = 1 / curScale;\n      } else {\n        scaleBy = this.props.maxScale / curScale;\n      }\n\n      var rect = transformedRect(this.transformedContentRect(), new Transform(scaleBy, 0, 0, {\n        x: pivotX,\n        y: pivotY\n      }));\n      rect = transformedRect(rect, new Transform(1, this.viewPortRect().centerX() - pivotX, this.viewPortRect().centerY() - pivotY));\n      rect = alignedRect(rect, this.viewPortRect());\n      this.animate(rect);\n    }\n  }, {\n    key: \"applyResistance\",\n    value: function applyResistance(dx, dy) {\n      var availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n\n      if (dx > 0 && availablePanDistance.left < 0 || dx < 0 && availablePanDistance.right < 0) {\n        dx /= 3;\n      }\n\n      if (dy > 0 && availablePanDistance.top < 0 || dy < 0 && availablePanDistance.bottom < 0) {\n        dy /= 3;\n      }\n\n      return {\n        dx: dx,\n        dy: dy\n      };\n    }\n  }, {\n    key: \"cancelAnimation\",\n    value: function cancelAnimation() {\n      this.state.animator.stopAnimation();\n    }\n  }, {\n    key: \"animate\",\n    value: function animate(targetRect, durationInMillis) {\n      var _this4 = this;\n\n      var duration = 200;\n\n      if (durationInMillis) {\n        duration = durationInMillis;\n      }\n\n      var fromRect = this.transformedContentRect();\n\n      if (fromRect.equals(targetRect, 0.01)) {\n        return;\n      }\n\n      this.state.animator.removeAllListeners();\n      this.state.animator.setValue(0);\n      this.state.animator.addListener(function (state) {\n        var progress = state.value;\n        var left = fromRect.left + (targetRect.left - fromRect.left) * progress;\n        var right = fromRect.right + (targetRect.right - fromRect.right) * progress;\n        var top = fromRect.top + (targetRect.top - fromRect.top) * progress;\n        var bottom = fromRect.bottom + (targetRect.bottom - fromRect.bottom) * progress;\n        var transform = getTransform(_this4.contentRect(), new Rect(left, top, right, bottom));\n\n        _this4.updateTransform(transform);\n      });\n      Animated.timing(this.state.animator, {\n        toValue: 1,\n        duration: duration,\n        easing: Easing.inOut(Easing.ease)\n      }).start();\n    }\n  }, {\n    key: \"animateBounce\",\n    value: function animateBounce() {\n      var curScale = this.state.scale;\n      var minScale = 1;\n      var maxScale = this.props.maxScale;\n      var scaleBy = 1;\n\n      if (curScale > maxScale) {\n        scaleBy = maxScale / curScale;\n      } else if (curScale < minScale) {\n        scaleBy = minScale / curScale;\n      }\n\n      var rect = transformedRect(this.transformedContentRect(), new Transform(scaleBy, 0, 0, {\n        x: this.viewPortRect().centerX(),\n        y: this.viewPortRect().centerY()\n      }));\n      rect = alignedRect(rect, this.viewPortRect());\n      this.animate(rect);\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform(transform) {\n      this.setState(transform);\n    }\n  }, {\n    key: \"forceUpdateTransform\",\n    value: function forceUpdateTransform(transform) {\n      this.setState(transform);\n    }\n  }, {\n    key: \"getAvailableTranslateSpace\",\n    value: function getAvailableTranslateSpace() {\n      return availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n    }\n  }]);\n\n  return ViewTransformer;\n}(React.Component);\n\nViewTransformer.Rect = Rect;\nViewTransformer.getTransform = getTransform;\nViewTransformer.propTypes = {\n  enableTransform: PropTypes.bool,\n  enableScale: PropTypes.bool,\n  enableTranslate: PropTypes.bool,\n  maxOverScrollDistance: PropTypes.number,\n  maxScale: PropTypes.number,\n  contentAspectRatio: PropTypes.number,\n  enableResistance: PropTypes.bool,\n  onViewTransformed: PropTypes.func,\n  onTransformGestureReleased: PropTypes.func,\n  onSingleTapConfirmed: PropTypes.func,\n  onLayout: PropTypes.func,\n  onTransformStart: PropTypes.func,\n  children: PropTypes.node\n};\nViewTransformer.defaultProps = {\n  maxOverScrollDistance: 20,\n  enableScale: true,\n  enableTranslate: true,\n  enableTransform: true,\n  maxScale: 1,\n  enableResistance: false\n};\nexport { ViewTransformer as default };","map":{"version":3,"sources":["C:/Users/takia/OneDrive/Desktop/Data/Projects/mobile_app/mobile_app/Handoff/node_modules/react-native-image-gallery/src/libraries/ViewTransformer/index.js"],"names":["React","ReactNative","Scroller","PropTypes","createResponder","Rect","Transform","transformedRect","availableTranslateSpace","fitCenterRect","alignedRect","getTransform","ViewTransformer","props","state","scale","translateX","translateY","animator","Animated","Value","width","height","pageX","pageY","_viewPortRect","onLayout","bind","cancelAnimation","contentRect","transformedContentRect","animate","scroller","dx","dy","isFinished","animateBounce","updateTransform","set","rect","viewPortRect","copy","contentAspectRatio","currentTransform","gestureResponder","onStartShouldSetResponder","evt","gestureState","onMoveShouldSetResponderCapture","onResponderMove","onResponderGrant","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","onResponderSingleTapConfirmed","onSingleTapConfirmed","prevProps","prevState","onViewTransformed","enableTransform","flex","transform","children","e","nativeEvent","layout","setState","measureLayout","handle","findNodeHandle","refs","NativeModules","UIManager","measure","x","y","onTransformStart","responderGranted","moveX","previousMoveX","moveY","previousMoveY","enableResistance","d","applyResistance","enableTranslate","previousPinch","pinch","enableScale","scaleBy","pivotX","pivotY","Math","abs","handled","onTransformGestureReleased","doubleTapUp","x0","y0","performDoubleTapUp","performFling","vx","vy","startX","startY","maxX","minX","maxY","minY","availablePanDistance","left","maxOverScrollDistance","right","top","bottom","fling","curScale","maxScale","centerX","centerY","stopAnimation","targetRect","durationInMillis","duration","fromRect","equals","removeAllListeners","setValue","addListener","progress","value","timing","toValue","easing","Easing","inOut","ease","start","minScale","Component","propTypes","bool","number","func","node","defaultProps"],"mappings":"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","sourcesContent":["import React from 'react';\nimport ReactNative, { View, Animated, Easing, NativeModules } from 'react-native';\nimport Scroller from '../Scroller';\nimport PropTypes from 'prop-types';\nimport { createResponder } from '../GestureResponder';\nimport { Rect, Transform, transformedRect, availableTranslateSpace, fitCenterRect, alignedRect, getTransform } from './TransformUtils';\n\nexport default class ViewTransformer extends React.Component {\n    static Rect = Rect;\n    static getTransform = getTransform;\n\n    static propTypes = {\n        enableTransform: PropTypes.bool,\n        enableScale: PropTypes.bool,\n        enableTranslate: PropTypes.bool,\n        maxOverScrollDistance: PropTypes.number,\n        maxScale: PropTypes.number,\n        contentAspectRatio: PropTypes.number,\n        enableResistance: PropTypes.bool,\n        onViewTransformed: PropTypes.func,\n        onTransformGestureReleased: PropTypes.func,\n        onSingleTapConfirmed: PropTypes.func,\n        onLayout: PropTypes.func,\n        onTransformStart: PropTypes.func,\n        children: PropTypes.node\n    };\n\n    static defaultProps = {\n        maxOverScrollDistance: 20,\n        enableScale: true,\n        enableTranslate: true,\n        enableTransform: true,\n        maxScale: 1,\n        enableResistance: false\n    };\n\n    constructor (props) {\n        super(props);\n        this.state = {\n            // transform state\n            scale: 1,\n            translateX: 0,\n            translateY: 0,\n            // animation state\n            animator: new Animated.Value(0),\n            // layout\n            width: 0,\n            height: 0,\n            pageX: 0,\n            pageY: 0\n        };\n        this._viewPortRect = new Rect(); // A holder to avoid new too much\n\n        this.onLayout = this.onLayout.bind(this);\n        this.cancelAnimation = this.cancelAnimation.bind(this);\n        this.contentRect = this.contentRect.bind(this);\n        this.transformedContentRect = this.transformedContentRect.bind(this);\n        this.animate = this.animate.bind(this);\n\n        this.scroller = new Scroller(true, (dx, dy, scroller) => {\n            if (dx === 0 && dy === 0 && scroller.isFinished()) {\n                this.animateBounce();\n                return;\n            }\n\n            this.updateTransform({\n                translateX: this.state.translateX + dx / this.state.scale,\n                translateY: this.state.translateY + dy / this.state.scale\n            });\n        });\n    }\n\n    viewPortRect () {\n        this._viewPortRect.set(0, 0, this.state.width, this.state.height);\n        return this._viewPortRect;\n    }\n\n    contentRect () {\n        let rect = this.viewPortRect().copy();\n        if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n            rect = fitCenterRect(this.props.contentAspectRatio, rect);\n        }\n        return rect;\n    }\n\n    transformedContentRect () {\n        let rect = transformedRect(this.viewPortRect(), this.currentTransform());\n        if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n            rect = fitCenterRect(this.props.contentAspectRatio, rect);\n        }\n        return rect;\n    }\n\n    currentTransform () {\n        return new Transform(this.state.scale, this.state.translateX, this.state.translateY);\n    }\n\n    componentWillMount () {\n        this.gestureResponder = createResponder({\n            onStartShouldSetResponder: (evt, gestureState) => true,\n            onMoveShouldSetResponderCapture: (evt, gestureState) => true,\n            // onMoveShouldSetResponder: this.handleMove,\n            onResponderMove: this.onResponderMove,\n            onResponderGrant: this.onResponderGrant,\n            onResponderRelease: this.onResponderRelease,\n            onResponderTerminate: this.onResponderRelease,\n            onResponderTerminationRequest: (evt, gestureState) => false, // Do not allow parent view to intercept gesture\n            onResponderSingleTapConfirmed: (evt, gestureState) => {\n                this.props.onSingleTapConfirmed && this.props.onSingleTapConfirmed();\n            }\n        });\n    }\n\n    componentDidUpdate (prevProps, prevState) {\n        this.props.onViewTransformed && this.props.onViewTransformed({\n            scale: this.state.scale,\n            translateX: this.state.translateX,\n            translateY: this.state.translateY\n        });\n    }\n\n    componentWillUnmount () {\n        this.cancelAnimation();\n    }\n\n    render () {\n        let gestureResponder = this.gestureResponder;\n        if (!this.props.enableTransform) {\n            gestureResponder = {};\n        }\n\n        return (\n            <View\n              {...this.props}\n              {...gestureResponder}\n              ref={'innerViewRef'}\n              onLayout={this.onLayout}>\n                 <View\n                   style={{\n                       flex: 1,\n                       transform: [\n                          { scale: this.state.scale },\n                          { translateX: this.state.translateX },\n                          { translateY: this.state.translateY }\n                       ]\n                   }}>\n                    { this.props.children }\n                </View>\n            </View>\n        );\n    }\n\n    onLayout (e) {\n        const {width, height} = e.nativeEvent.layout;\n        if (width !== this.state.width || height !== this.state.height) {\n            this.setState({width, height});\n        }\n        this.measureLayout();\n\n        this.props.onLayout && this.props.onLayout(e);\n    }\n\n    measureLayout () {\n        let handle = ReactNative.findNodeHandle(this.refs['innerViewRef']);\n        NativeModules.UIManager.measure(handle, (x, y, width, height, pageX, pageY) => {\n            if (typeof pageX === 'number' && typeof pageY === 'number') { // avoid undefined values on Android devices\n                if (this.state.pageX !== pageX || this.state.pageY !== pageY) {\n                    this.setState({ pageX: pageX, pageY: pageY });\n                }\n            }\n        });\n    }\n\n    onResponderGrant (evt, gestureState) {\n        this.props.onTransformStart && this.props.onTransformStart();\n        this.setState({responderGranted: true});\n        this.measureLayout();\n    }\n\n    onResponderMove (evt, gestureState) {\n        this.cancelAnimation();\n\n        let dx = gestureState.moveX - gestureState.previousMoveX;\n        let dy = gestureState.moveY - gestureState.previousMoveY;\n        if (this.props.enableResistance) {\n            let d = this.applyResistance(dx, dy);\n            dx = d.dx;\n            dy = d.dy;\n        }\n\n        if (!this.props.enableTranslate) {\n            dx = dy = 0;\n        }\n\n        let transform = {};\n        if (gestureState.previousPinch && gestureState.pinch && this.props.enableScale) {\n            let scaleBy = gestureState.pinch / gestureState.previousPinch;\n            let pivotX = gestureState.moveX - this.state.pageX;\n            let pivotY = gestureState.moveY - this.state.pageY;\n\n            let rect = transformedRect(\n                transformedRect(\n                    this.contentRect(),\n                    this.currentTransform()\n                ),\n                new Transform(scaleBy, dx, dy, { x: pivotX, y: pivotY })\n            );\n            transform = getTransform(this.contentRect(), rect);\n        } else {\n            if (Math.abs(dx) > 2 * Math.abs(dy)) {\n                dy = 0;\n            } else if (Math.abs(dy) > 2 * Math.abs(dx)) {\n                dx = 0;\n            }\n            transform.translateX = this.state.translateX + dx / this.state.scale;\n            transform.translateY = this.state.translateY + dy / this.state.scale;\n        }\n\n        this.updateTransform(transform);\n        return true;\n    }\n\n    onResponderRelease (evt, gestureState) {\n        let handled = this.props.onTransformGestureReleased && this.props.onTransformGestureReleased({\n            scale: this.state.scale,\n            translateX: this.state.translateX,\n            translateY: this.state.translateY\n        });\n        if (handled) {\n            return;\n        }\n\n        if (gestureState.doubleTapUp) {\n            if (!this.props.enableScale) {\n                this.animateBounce();\n                return;\n            }\n            let pivotX = 0;\n            let pivotY = 0;\n            if (gestureState.dx || gestureState.dy) {\n                pivotX = gestureState.moveX - this.state.pageX;\n                pivotY = gestureState.moveY - this.state.pageY;\n            } else {\n                pivotX = gestureState.x0 - this.state.pageX;\n                pivotY = gestureState.y0 - this.state.pageY;\n            }\n\n            this.performDoubleTapUp(pivotX, pivotY);\n        } else {\n            if (this.props.enableTranslate) {\n                this.performFling(gestureState.vx, gestureState.vy);\n            } else {\n                this.animateBounce();\n            }\n        }\n    }\n\n    performFling (vx, vy) {\n        let startX = 0;\n        let startY = 0;\n        let maxX, minX, maxY, minY;\n        let availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n        if (vx > 0) {\n            minX = 0;\n            if (availablePanDistance.left > 0) {\n                maxX = availablePanDistance.left + this.props.maxOverScrollDistance;\n            } else {\n                maxX = 0;\n            }\n        } else {\n            maxX = 0;\n            if (availablePanDistance.right > 0) {\n                minX = -availablePanDistance.right - this.props.maxOverScrollDistance;\n            } else {\n                minX = 0;\n            }\n        }\n        if (vy > 0) {\n            minY = 0;\n            if (availablePanDistance.top > 0) {\n                maxY = availablePanDistance.top + this.props.maxOverScrollDistance;\n            } else {\n                maxY = 0;\n            }\n        } else {\n            maxY = 0;\n            if (availablePanDistance.bottom > 0) {\n                minY = -availablePanDistance.bottom - this.props.maxOverScrollDistance;\n            } else {\n                minY = 0;\n            }\n        }\n\n        vx *= 1000; // per second\n        vy *= 1000;\n        if (Math.abs(vx) > 2 * Math.abs(vy)) {\n            vy = 0;\n        } else if (Math.abs(vy) > 2 * Math.abs(vx)) {\n            vx = 0;\n        }\n\n        this.scroller.fling(startX, startY, vx, vy, minX, maxX, minY, maxY);\n    }\n\n    performDoubleTapUp (pivotX, pivotY) {\n        let curScale = this.state.scale;\n        let scaleBy;\n        if (curScale > (1 + this.props.maxScale) / 2) {\n            scaleBy = 1 / curScale;\n        } else {\n            scaleBy = this.props.maxScale / curScale;\n        }\n\n        let rect = transformedRect(\n            this.transformedContentRect(),\n            new Transform(scaleBy, 0, 0, { x: pivotX, y: pivotY })\n        );\n        rect = transformedRect(\n            rect,\n            new Transform(\n                1,\n                this.viewPortRect().centerX() - pivotX,\n                this.viewPortRect().centerY() - pivotY\n            )\n        );\n        rect = alignedRect(rect, this.viewPortRect());\n        this.animate(rect);\n    }\n\n    applyResistance (dx, dy) {\n        let availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n\n        if ((dx > 0 && availablePanDistance.left < 0) ||\n        (dx < 0 && availablePanDistance.right < 0)) {\n            dx /= 3;\n        }\n        if ((dy > 0 && availablePanDistance.top < 0) ||\n        (dy < 0 && availablePanDistance.bottom < 0)) {\n            dy /= 3;\n        }\n        return { dx, dy };\n    }\n\n    cancelAnimation () {\n        this.state.animator.stopAnimation();\n    }\n\n    animate (targetRect, durationInMillis) {\n        let duration = 200;\n        if (durationInMillis) {\n            duration = durationInMillis;\n        }\n\n        let fromRect = this.transformedContentRect();\n        if (fromRect.equals(targetRect, 0.01)) {\n            return;\n        }\n\n        this.state.animator.removeAllListeners();\n        this.state.animator.setValue(0);\n        this.state.animator.addListener((state) => {\n            let progress = state.value;\n\n            let left = fromRect.left + (targetRect.left - fromRect.left) * progress;\n            let right = fromRect.right + (targetRect.right - fromRect.right) * progress;\n            let top = fromRect.top + (targetRect.top - fromRect.top) * progress;\n            let bottom = fromRect.bottom + (targetRect.bottom - fromRect.bottom) * progress;\n\n            let transform = getTransform(this.contentRect(), new Rect(left, top, right, bottom));\n            this.updateTransform(transform);\n        });\n\n        Animated.timing(\n            this.state.animator,\n            {\n                toValue: 1,\n                duration: duration,\n                easing: Easing.inOut(Easing.ease)\n            }\n        ).start();\n    }\n\n    animateBounce () {\n        let curScale = this.state.scale;\n        let minScale = 1;\n        let maxScale = this.props.maxScale;\n        let scaleBy = 1;\n        if (curScale > maxScale) {\n            scaleBy = maxScale / curScale;\n        } else if (curScale < minScale) {\n            scaleBy = minScale / curScale;\n        }\n\n        let rect = transformedRect(\n            this.transformedContentRect(),\n            new Transform(\n                scaleBy,\n                0,\n                0,\n                {\n                    x: this.viewPortRect().centerX(),\n                    y: this.viewPortRect().centerY()\n                }\n            )\n        );\n        rect = alignedRect(rect, this.viewPortRect());\n        this.animate(rect);\n    }\n\n    updateTransform (transform) {\n        this.setState(transform);\n    }\n\n    forceUpdateTransform (transform) {\n        this.setState(transform);\n    }\n\n    getAvailableTranslateSpace () {\n        return availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n    }\n}\n"]},"metadata":{},"sourceType":"module"}