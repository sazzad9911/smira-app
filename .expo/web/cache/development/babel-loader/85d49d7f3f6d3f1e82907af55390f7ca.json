{"ast":null,"code":"'use strict';\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport TouchHistoryMath from \"./TouchHistoryMath\";\nimport { pinchDistance } from \"./TouchDistanceMath\";\nimport TimerMixin from 'react-timer-mixin';\nvar currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.currentCentroidXOfTouchesChangedAfter;\nvar currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.currentCentroidYOfTouchesChangedAfter;\nvar previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.previousCentroidXOfTouchesChangedAfter;\nvar previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.previousCentroidYOfTouchesChangedAfter;\nvar currentCentroidX = TouchHistoryMath.currentCentroidX;\nvar currentCentroidY = TouchHistoryMath.currentCentroidY;\nvar TAP_UP_TIME_THRESHOLD = 400;\nvar TAP_MOVE_THRESHOLD = 10;\nvar MOVE_THRESHOLD = 2;\nvar DEV = false;\n\nfunction initializeGestureState(gestureState) {\n  gestureState.moveX = 0;\n  gestureState.moveY = 0;\n  gestureState.x0 = 0;\n  gestureState.y0 = 0;\n  gestureState.dx = 0;\n  gestureState.dy = 0;\n  gestureState.vx = 0;\n  gestureState.vy = 0;\n  gestureState.numberActiveTouches = 0;\n  gestureState._accountsForMovesUpTo = 0;\n  gestureState.previousMoveX = 0;\n  gestureState.previousMoveY = 0;\n  gestureState.pinch = undefined;\n  gestureState.previousPinch = undefined;\n  gestureState.singleTapUp = false;\n  gestureState.doubleTapUp = false;\n  gestureState._singleTabFailed = false;\n}\n\nfunction updateGestureStateOnMove(gestureState, touchHistory, e) {\n  var movedAfter = gestureState._accountsForMovesUpTo;\n  var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n  var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n  var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n  var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n  var dx = x - prevX;\n  var dy = y - prevY;\n  gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n  gestureState.moveX = x;\n  gestureState.moveY = y;\n  var dt = convertToMillisecIfNeeded(touchHistory.mostRecentTimeStamp - movedAfter);\n  gestureState.vx = dx / dt;\n  gestureState.vy = dy / dt;\n  gestureState.dx += dx;\n  gestureState.dy += dy;\n  gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\n  gestureState.previousMoveX = prevX;\n  gestureState.previousMoveY = prevY;\n  gestureState.pinch = pinchDistance(touchHistory, movedAfter, true);\n  gestureState.previousPinch = pinchDistance(touchHistory, movedAfter, false);\n}\n\nfunction clearInteractionHandle(interactionState) {\n  if (interactionState.handle) {\n    InteractionManager.clearInteractionHandle(interactionState.handle);\n    interactionState.handle = null;\n  }\n}\n\nfunction convertToMillisecIfNeeded(interval) {\n  if (interval > 1000000) {\n    return interval / 1000000;\n  }\n\n  return interval;\n}\n\nfunction cancelSingleTapConfirm(gestureState) {\n  if (typeof gestureState._singleTapConfirmId !== 'undefined') {\n    TimerMixin.clearTimeout(gestureState._singleTapConfirmId);\n    gestureState._singleTapConfirmId = undefined;\n  }\n}\n\nexport default function create(config) {\n  if (config.debug) {\n    DEV = true;\n  }\n\n  var interactionState = {\n    handle: null\n  };\n  var gestureState = {\n    stateID: Math.random()\n  };\n  initializeGestureState(gestureState);\n  var handlers = {\n    onStartShouldSetResponder: function onStartShouldSetResponder(e) {\n      DEV && console.log('onStartShouldSetResponder...');\n      cancelSingleTapConfirm(gestureState);\n      return config.onStartShouldSetResponder ? config.onStartShouldSetResponder(e, gestureState) : false;\n    },\n    onMoveShouldSetResponder: function onMoveShouldSetResponder(e) {\n      DEV && console.log('onMoveShouldSetResponder...');\n      return config.onMoveShouldSetResponder && effectiveMove(config, gestureState) ? config.onMoveShouldSetResponder(e, gestureState) : false;\n    },\n    onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(e) {\n      DEV && console.log('onStartShouldSetResponderCapture...');\n      cancelSingleTapConfirm(gestureState);\n\n      if (e.nativeEvent.touches.length === 1) {\n        initializeGestureState(gestureState);\n      }\n\n      gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;\n      return config.onStartShouldSetResponderCapture ? config.onStartShouldSetResponderCapture(e, gestureState) : false;\n    },\n    onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(e) {\n      DEV && console.log('onMoveShouldSetResponderCapture...');\n      var touchHistory = e.touchHistory;\n\n      if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n        return false;\n      }\n\n      updateGestureStateOnMove(gestureState, touchHistory, e);\n      return config.onMoveShouldSetResponderCapture && effectiveMove(config, gestureState) ? config.onMoveShouldSetResponderCapture(e, gestureState) : false;\n    },\n    onResponderGrant: function onResponderGrant(e) {\n      DEV && console.log('onResponderGrant...');\n      cancelSingleTapConfirm(gestureState);\n\n      if (!interactionState.handle) {\n        interactionState.handle = InteractionManager.createInteractionHandle();\n      }\n\n      gestureState._grantTimestamp = e.touchHistory.mostRecentTimeStamp;\n      gestureState.x0 = currentCentroidX(e.touchHistory);\n      gestureState.y0 = currentCentroidY(e.touchHistory);\n      gestureState.dx = 0;\n      gestureState.dy = 0;\n\n      if (config.onResponderGrant) {\n        config.onResponderGrant(e, gestureState);\n      }\n\n      return config.onShouldBlockNativeResponder === undefined ? true : config.onShouldBlockNativeResponder();\n    },\n    onResponderReject: function onResponderReject(e) {\n      DEV && console.log('onResponderReject...');\n      clearInteractionHandle(interactionState);\n      config.onResponderReject && config.onResponderReject(e, gestureState);\n    },\n    onResponderRelease: function onResponderRelease(e) {\n      if (gestureState.singleTapUp) {\n        if (gestureState._lastSingleTapUp) {\n          if (convertToMillisecIfNeeded(e.touchHistory.mostRecentTimeStamp - gestureState._lastReleaseTimestamp) < TAP_UP_TIME_THRESHOLD) {\n            gestureState.doubleTapUp = true;\n          }\n        }\n\n        gestureState._lastSingleTapUp = true;\n\n        if (!gestureState.doubleTapUp) {\n          var snapshot = _extends({}, gestureState);\n\n          var timeoutId = TimerMixin.setTimeout(function () {\n            if (gestureState._singleTapConfirmId === timeoutId) {\n              DEV && console.log('onResponderSingleTapConfirmed...');\n              config.onResponderSingleTapConfirmed && config.onResponderSingleTapConfirmed(e, snapshot);\n            }\n          }, TAP_UP_TIME_THRESHOLD);\n          gestureState._singleTapConfirmId = timeoutId;\n        }\n      }\n\n      gestureState._lastReleaseTimestamp = e.touchHistory.mostRecentTimeStamp;\n      DEV && console.log('onResponderRelease...' + JSON.stringify(gestureState));\n      clearInteractionHandle(interactionState);\n      config.onResponderRelease && config.onResponderRelease(e, gestureState);\n      initializeGestureState(gestureState);\n    },\n    onResponderStart: function onResponderStart(e) {\n      DEV && console.log('onResponderStart...');\n      var touchHistory = e.touchHistory;\n      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n\n      if (config.onResponderStart) {\n        config.onResponderStart(e, gestureState);\n      }\n    },\n    onResponderMove: function onResponderMove(e) {\n      var touchHistory = e.touchHistory;\n\n      if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n        return;\n      }\n\n      updateGestureStateOnMove(gestureState, touchHistory, e);\n      DEV && console.log('onResponderMove...' + JSON.stringify(gestureState));\n\n      if (config.onResponderMove && effectiveMove(config, gestureState)) {\n        config.onResponderMove(e, gestureState);\n      }\n    },\n    onResponderEnd: function onResponderEnd(e) {\n      var touchHistory = e.touchHistory;\n      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n\n      if (touchHistory.numberActiveTouches > 0 || convertToMillisecIfNeeded(touchHistory.mostRecentTimeStamp - gestureState._grantTimestamp) > TAP_UP_TIME_THRESHOLD || Math.abs(gestureState.dx) >= TAP_MOVE_THRESHOLD || Math.abs(gestureState.dy) >= TAP_MOVE_THRESHOLD) {\n        gestureState._singleTabFailed = true;\n      }\n\n      if (!gestureState._singleTabFailed) {\n        gestureState.singleTapUp = true;\n      }\n\n      DEV && console.log('onResponderEnd...' + JSON.stringify(gestureState));\n      clearInteractionHandle(interactionState);\n      config.onResponderEnd && config.onResponderEnd(e, gestureState);\n    },\n    onResponderTerminate: function onResponderTerminate(e) {\n      DEV && console.log('onResponderTerminate...');\n      clearInteractionHandle(interactionState);\n      config.onResponderTerminate && config.onResponderTerminate(e, gestureState);\n      initializeGestureState(gestureState);\n    },\n    onResponderTerminationRequest: function onResponderTerminationRequest(e) {\n      DEV && console.log('onResponderTerminationRequest...');\n      return config.onResponderTerminationRequest ? config.onResponderTerminationRequest(e.gestureState) : true;\n    }\n  };\n  return _objectSpread({}, handlers);\n}\n\nfunction effectiveMove(config, gestureState) {\n  if (gestureState.numberActiveTouches > 1) {\n    return true;\n  }\n\n  var moveThreshold = MOVE_THRESHOLD;\n\n  if (typeof config.moveThreshold === 'number') {\n    moveThreshold = config.minMoveDistance;\n  }\n\n  if (Math.abs(gestureState.dx) >= moveThreshold || Math.abs(gestureState.dy) >= moveThreshold) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["C:/Users/takia/OneDrive/Desktop/Data/Projects/mobile_app/mobile_app/Handoff/node_modules/react-native-image-gallery/src/libraries/GestureResponder/createResponder.js"],"names":["TouchHistoryMath","pinchDistance","TimerMixin","currentCentroidXOfTouchesChangedAfter","currentCentroidYOfTouchesChangedAfter","previousCentroidXOfTouchesChangedAfter","previousCentroidYOfTouchesChangedAfter","currentCentroidX","currentCentroidY","TAP_UP_TIME_THRESHOLD","TAP_MOVE_THRESHOLD","MOVE_THRESHOLD","DEV","initializeGestureState","gestureState","moveX","moveY","x0","y0","dx","dy","vx","vy","numberActiveTouches","_accountsForMovesUpTo","previousMoveX","previousMoveY","pinch","undefined","previousPinch","singleTapUp","doubleTapUp","_singleTabFailed","updateGestureStateOnMove","touchHistory","e","movedAfter","prevX","x","prevY","y","dt","convertToMillisecIfNeeded","mostRecentTimeStamp","clearInteractionHandle","interactionState","handle","InteractionManager","interval","cancelSingleTapConfirm","_singleTapConfirmId","clearTimeout","create","config","debug","stateID","Math","random","handlers","onStartShouldSetResponder","console","log","onMoveShouldSetResponder","effectiveMove","onStartShouldSetResponderCapture","nativeEvent","touches","length","onMoveShouldSetResponderCapture","onResponderGrant","createInteractionHandle","_grantTimestamp","onShouldBlockNativeResponder","onResponderReject","onResponderRelease","_lastSingleTapUp","_lastReleaseTimestamp","snapshot","timeoutId","setTimeout","onResponderSingleTapConfirmed","JSON","stringify","onResponderStart","onResponderMove","onResponderEnd","abs","onResponderTerminate","onResponderTerminationRequest","moveThreshold","minMoveDistance"],"mappings":"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","sourcesContent":["/**\n * Inspired by 'PanResponder' from Facebook.\n */\n\n'use strict';\n\nimport {InteractionManager} from 'react-native';\nimport TouchHistoryMath from './TouchHistoryMath'; // copied from react/lib/TouchHistoryMath.js\nimport {pinchDistance} from './TouchDistanceMath';\nimport TimerMixin from 'react-timer-mixin';\n\nconst currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.currentCentroidXOfTouchesChangedAfter;\nconst currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.currentCentroidYOfTouchesChangedAfter;\nconst previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.previousCentroidXOfTouchesChangedAfter;\nconst previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.previousCentroidYOfTouchesChangedAfter;\nconst currentCentroidX = TouchHistoryMath.currentCentroidX;\nconst currentCentroidY = TouchHistoryMath.currentCentroidY;\n\nconst TAP_UP_TIME_THRESHOLD = 400;\nconst TAP_MOVE_THRESHOLD = 10;\nconst MOVE_THRESHOLD = 2;\n\nlet DEV = false;\n\nfunction initializeGestureState (gestureState) {\n    gestureState.moveX = 0;\n    gestureState.moveY = 0;\n    gestureState.x0 = 0;\n    gestureState.y0 = 0;\n    gestureState.dx = 0;\n    gestureState.dy = 0;\n    gestureState.vx = 0;\n    gestureState.vy = 0;\n    gestureState.numberActiveTouches = 0;\n  // All `gestureState` accounts for timeStamps up until:\n    gestureState._accountsForMovesUpTo = 0;\n\n    gestureState.previousMoveX = 0;\n    gestureState.previousMoveY = 0;\n    gestureState.pinch = undefined;\n    gestureState.previousPinch = undefined;\n    gestureState.singleTapUp = false;\n    gestureState.doubleTapUp = false;\n    gestureState._singleTabFailed = false;\n}\n\nfunction updateGestureStateOnMove (gestureState, touchHistory, e) {\n    const movedAfter = gestureState._accountsForMovesUpTo;\n    const prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n    const x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n    const prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n    const y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n    const dx = x - prevX;\n    const dy = y - prevY;\n\n    gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n    gestureState.moveX = x;\n    gestureState.moveY = y;\n\n  // TODO: This must be filtered intelligently.\n  // const dt = touchHistory.mostRecentTimeStamp - movedAfter;\n    const dt = convertToMillisecIfNeeded(touchHistory.mostRecentTimeStamp - movedAfter);\n    gestureState.vx = dx / dt;\n    gestureState.vy = dy / dt;\n    gestureState.dx += dx;\n    gestureState.dy += dy;\n    gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\n\n    gestureState.previousMoveX = prevX;\n    gestureState.previousMoveY = prevY;\n    gestureState.pinch = pinchDistance(touchHistory, movedAfter, true);\n    gestureState.previousPinch = pinchDistance(touchHistory, movedAfter, false);\n}\n\nfunction clearInteractionHandle (interactionState) {\n    if (interactionState.handle) {\n        InteractionManager.clearInteractionHandle(interactionState.handle);\n        interactionState.handle = null;\n    }\n}\n\n/**\n * Due to commit https://github.com/facebook/react-native/commit/f2c1868b56bdfc8b0d6f448733848eafed2cd440,\n * Android is using nanoseconds while iOS is using milliseconds.\n * @param interval\n * @returns {*}\n */\nfunction convertToMillisecIfNeeded (interval) {\n    if (interval > 1000000) {\n        return interval / 1000000;\n    }\n    return interval;\n}\n\nfunction cancelSingleTapConfirm (gestureState) {\n    if (typeof gestureState._singleTapConfirmId !== 'undefined') {\n        TimerMixin.clearTimeout(gestureState._singleTapConfirmId);\n        gestureState._singleTapConfirmId = undefined;\n    }\n}\n\n/**\n * The config object contains same callbacks as the default gesture responder(https://facebook.github.io/react-native/docs/gesture-responder-system.html).\n * And every callback are called with an additional argument 'gestureState', like PanResponder.\n * @param config\n * @returns {{}}\n */\n\n/**\n * The config object contains same callbacks as the default gesture responder(https://facebook.github.io/react-native/docs/gesture-responder-system.html).\n * And every callback are called with an additional argument 'gestureState', like PanResponder.\n * @param config\n * @param debug true to enable debug logs\n * @returns {{}}\n */\nexport default function create (config) {\n    if (config.debug) {\n        DEV = true;\n    }\n\n    const interactionState = {\n        handle: null\n    };\n    const gestureState = {\n    // Useful for debugging\n        stateID: Math.random()\n    };\n    initializeGestureState(gestureState);\n\n    const handlers = {\n        onStartShouldSetResponder: function (e) {\n            DEV && console.log('onStartShouldSetResponder...');\n            cancelSingleTapConfirm(gestureState);\n            return config.onStartShouldSetResponder ?\n        config.onStartShouldSetResponder(e, gestureState) :\n        false;\n        },\n        onMoveShouldSetResponder: function (e) {\n            DEV && console.log('onMoveShouldSetResponder...');\n\n            return config.onMoveShouldSetResponder && effectiveMove(config, gestureState) ?\n        config.onMoveShouldSetResponder(e, gestureState) :\n        false;\n        },\n        onStartShouldSetResponderCapture: function (e) {\n            DEV && console.log('onStartShouldSetResponderCapture...');\n            cancelSingleTapConfirm(gestureState);\n      // TODO: Actually, we should reinitialize the state any time\n      // touches.length increases from 0 active to > 0 active.\n            if (e.nativeEvent.touches.length === 1) {\n                initializeGestureState(gestureState);\n            }\n            gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;\n            return config.onStartShouldSetResponderCapture ?\n        config.onStartShouldSetResponderCapture(e, gestureState) :\n        false;\n        },\n\n        onMoveShouldSetResponderCapture: function (e) {\n            DEV && console.log('onMoveShouldSetResponderCapture...');\n            const touchHistory = e.touchHistory;\n      // Responder system incorrectly dispatches should* to current responder\n      // Filter out any touch moves past the first one - we would have\n      // already processed multi-touch geometry during the first event.\n            if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n                return false;\n            }\n            updateGestureStateOnMove(gestureState, touchHistory, e);\n            return config.onMoveShouldSetResponderCapture && effectiveMove(config, gestureState) ?\n        config.onMoveShouldSetResponderCapture(e, gestureState) :\n        false;\n        },\n\n        onResponderGrant: function (e) {\n            DEV && console.log('onResponderGrant...');\n            cancelSingleTapConfirm(gestureState);\n            if (!interactionState.handle) {\n                interactionState.handle = InteractionManager.createInteractionHandle();\n            }\n            gestureState._grantTimestamp = e.touchHistory.mostRecentTimeStamp;\n            gestureState.x0 = currentCentroidX(e.touchHistory);\n            gestureState.y0 = currentCentroidY(e.touchHistory);\n            gestureState.dx = 0;\n            gestureState.dy = 0;\n            if (config.onResponderGrant) {\n                config.onResponderGrant(e, gestureState);\n            }\n      // TODO: t7467124 investigate if this can be removed\n            return config.onShouldBlockNativeResponder === undefined ?\n        true :\n        config.onShouldBlockNativeResponder();\n        },\n\n        onResponderReject: function (e) {\n            DEV && console.log('onResponderReject...');\n            clearInteractionHandle(interactionState);\n            config.onResponderReject && config.onResponderReject(e, gestureState);\n        },\n\n        onResponderRelease: function (e) {\n            if (gestureState.singleTapUp) {\n                if (gestureState._lastSingleTapUp) {\n                    if (convertToMillisecIfNeeded(e.touchHistory.mostRecentTimeStamp - gestureState._lastReleaseTimestamp) < TAP_UP_TIME_THRESHOLD) {\n                      gestureState.doubleTapUp = true;\n                  }\n                }\n                gestureState._lastSingleTapUp = true;\n\n        // schedule to confirm single tap\n                if (!gestureState.doubleTapUp) {\n                    const snapshot = Object.assign({}, gestureState);\n                    const timeoutId = TimerMixin.setTimeout(() => {\n                      if (gestureState._singleTapConfirmId === timeoutId) {\n                        DEV && console.log('onResponderSingleTapConfirmed...');\n                        config.onResponderSingleTapConfirmed && config.onResponderSingleTapConfirmed(e, snapshot);\n                    }\n                  }, TAP_UP_TIME_THRESHOLD);\n                    gestureState._singleTapConfirmId = timeoutId;\n                }\n            }\n            gestureState._lastReleaseTimestamp = e.touchHistory.mostRecentTimeStamp;\n\n            DEV && console.log('onResponderRelease...' + JSON.stringify(gestureState));\n            clearInteractionHandle(interactionState);\n            config.onResponderRelease && config.onResponderRelease(e, gestureState);\n            initializeGestureState(gestureState);\n        },\n\n        onResponderStart: function (e) {\n            DEV && console.log('onResponderStart...');\n            const touchHistory = e.touchHistory;\n            gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n            if (config.onResponderStart) {\n                config.onResponderStart(e, gestureState);\n            }\n        },\n\n        onResponderMove: function (e) {\n            const touchHistory = e.touchHistory;\n      // Guard against the dispatch of two touch moves when there are two\n      // simultaneously changed touches.\n            if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n                return;\n            }\n      // Filter out any touch moves past the first one - we would have\n      // already processed multi-touch geometry during the first event.\n            updateGestureStateOnMove(gestureState, touchHistory, e);\n\n            DEV && console.log('onResponderMove...' + JSON.stringify(gestureState));\n            if (config.onResponderMove && effectiveMove(config, gestureState)) {\n                config.onResponderMove(e, gestureState);\n            }\n        },\n\n        onResponderEnd: function (e) {\n            const touchHistory = e.touchHistory;\n            gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n\n            if (touchHistory.numberActiveTouches > 0 ||\n        convertToMillisecIfNeeded(touchHistory.mostRecentTimeStamp - gestureState._grantTimestamp) > TAP_UP_TIME_THRESHOLD ||\n        Math.abs(gestureState.dx) >= TAP_MOVE_THRESHOLD ||\n        Math.abs(gestureState.dy) >= TAP_MOVE_THRESHOLD\n      ) {\n                gestureState._singleTabFailed = true;\n            }\n            if (!gestureState._singleTabFailed) {\n                gestureState.singleTapUp = true;\n            }\n\n            DEV && console.log('onResponderEnd...' + JSON.stringify(gestureState));\n            clearInteractionHandle(interactionState);\n            config.onResponderEnd && config.onResponderEnd(e, gestureState);\n        },\n\n        onResponderTerminate: function (e) {\n            DEV && console.log('onResponderTerminate...');\n            clearInteractionHandle(interactionState);\n            config.onResponderTerminate && config.onResponderTerminate(e, gestureState);\n            initializeGestureState(gestureState);\n        },\n\n        onResponderTerminationRequest: function (e) {\n            DEV && console.log('onResponderTerminationRequest...');\n            return config.onResponderTerminationRequest ?\n        config.onResponderTerminationRequest(e.gestureState) :\n        true;\n        }\n    };\n    return {...handlers};\n}\n\n/**\n * On Android devices, the default gesture responder is too sensitive that a single tap(no move intended) may trigger a move event.\n * We can use a moveThreshold config to avoid those unwanted move events.\n * @param config\n * @param gestureState\n * @returns {boolean}\n */\nfunction effectiveMove (config, gestureState) {\n    if (gestureState.numberActiveTouches > 1) {\n    // on iOS simulator, a pinch gesture(move with alt pressed) will not change gestureState.dx(always 0)\n        return true;\n    }\n\n    let moveThreshold = MOVE_THRESHOLD;\n    if (typeof config.moveThreshold === 'number') {\n        moveThreshold = config.minMoveDistance;\n    }\n    if (Math.abs(gestureState.dx) >= moveThreshold || Math.abs(gestureState.dy) >= moveThreshold) {\n        return true;\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"module"}